<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>知行合一</title>
    <link>https://fabletang.github.io/en/</link>
    <description>Recent content on 知行合一</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>Copyright © 2016-{year} Fable Tang. All Rights Reserved.</copyright>
    <lastBuildDate>Wed, 15 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://fabletang.github.io/en/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>hammerspoon config for mac</title>
      <link>https://fabletang.github.io/en/posts/2025-10-15-hammerspoon_config/</link>
      <pubDate>Wed, 15 Oct 2025 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2025-10-15-hammerspoon_config/</guid>
      <description>说明 Hammerspoon 是一款革命性的 macOS 桌面自动化工具，它将系统级 API 与灵活的 Lua 脚本引擎相结合。通过编写自定义的 Lua 脚本，您可以对系统进行强大的控制。
程序员一般的工作习惯都是两个显示屏幕，两个浏览器窗口，多个编程编辑器窗口，再加至少一个即时通讯工具,或者还有一个终端console。如果使用系统快捷键切换不够精确，用鼠标又不方便，特别是需要把光标移到扩展的显示屏的时候。Hammerspoon作为一个专业的macos自动化工具可以带领很大的方便。
如果快捷键不起作用，切换输入法为英文. 以下快捷键，里面有“+”号，表示分段，不代表键盘，先按前面部分，在1秒内再按后面部分。 vscode版本:1.80.1. 安装了golang,vim插件。macos 12.6. https://github.com/Hammerspoon/hammerspoon 环境 Macos 14 Hammerspoon 1.0.0 安装 官方连接 https://github.com/Hammerspoon/hammerspoon 参考说明，下载dmg文件安装或者brew安装均可。 默认功能快捷键 ⌘+, 为tab键上面的按键。弹出来一个选择窗口,如下: 再按数字或者字母，即可切换到对应的窗口。 自定义功能快捷键 点击右上角🔨图标，选择 “open config&amp;quot;,可以自己写lua脚本。再次选择 “reload config”即可生效。 lua脚本功能可参考github官网. 以下是我个人实现的一些功能，比如鼠标光标在主显示屏和扩展屏之间切换, vscode多个窗口循环切换等。 local hotswitchHs = require(&amp;#34;hotswitch-hs/hotswitch-hs&amp;#34;) -- hotswitchHs.enableAutoUpdate() -- If you don&amp;#39;t want to update automatically, remove this line. --hotswitchHs.setAutoGeneratedKeys({&amp;#34;1&amp;#34;, &amp;#34;2&amp;#34;, &amp;#34;3&amp;#34;, &amp;#34;4&amp;#34;, &amp;#34;5&amp;#34;, &amp;#34;6&amp;#34;, &amp;#34;7&amp;#34;, &amp;#34;8&amp;#34;, &amp;#34;9&amp;#34;, &amp;#34;0&amp;#34;}) hotswitchHs.enableAllSpaceWindows() hs.hotkey.bind({&amp;#34;command&amp;#34;}, &amp;#34;`&amp;#34;, hotswitchHs.</description>
    </item>
    
    <item>
      <title>vscode shortcut key for mac</title>
      <link>https://fabletang.github.io/en/posts/2023-07-23-vscode_shortcut_keyboard/</link>
      <pubDate>Sun, 23 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2023-07-23-vscode_shortcut_keyboard/</guid>
      <description>说明 如果快捷键不起作用，切换输入法为英文. 以下快捷键，里面有“+”号，表示分段，不代表键盘，先按前面部分，在1秒内再按后面部分。 vscode版本:1.80.1. 安装了golang,vim插件。macos 12.6. 一、文件切换 打开中的文本tab左右切换 : ⌥ ⌘ ←/→ 打开上次打开的文件(连续按tab选择) : ⌃ ⇥(tab) 关闭当前的文件 : ⌘ w 左侧文件浏览器选择文件,打开文件O : ↑/↓ 二、窗口 打开/关闭终端 : ⌃ ` 打开文件浏览器窗口 : ⌘ ⇧ B 打开/关闭左侧窗口 : ⌘ B 源代码管理 : ⌃ ⇧ G 打开/关闭问题窗口(↑/↓ 切换) : ⌘ ⇧ M 三、测试 运行光标所在的单元测试 : ⌘ ; + C 运行上次未通过的单元测试 : ⌘ ; + E 运行所有单元测试 : ⌘ ; + A 光标定位到测试出错点 : ⌥ ↩ </description>
    </item>
    
    <item>
      <title>为Go开发配置vscode</title>
      <link>https://fabletang.github.io/en/posts/2023-05-30-vscode-golang/</link>
      <pubDate>Tue, 30 May 2023 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2023-05-30-vscode-golang/</guid>
      <description>1. 安装 Go 按照以下步骤安装 Go：
在 Web 浏览器中，转到 “go.dev/doc/install”。 下载操作系统的版本。 下载后，运行安装程序。 打开命令提示符，然后运行 go version 以确认已安装 Go。 2. 安装Visual Studio Code 按照以下步骤安装Visual Studio Code：
在 Web 浏览器中，转到 “code.visualstudio.com”。 3. 安装 Go 扩展 在“Visual Studio Code”中，单击活动栏中的“扩展”图标，打开“扩展”视图。 或者 (Ctrl+Shift+X) 使用键盘快捷方式。 搜索 Go 扩展，然后选择“安装” 4. 更新 Go 工具 在Visual Studio Code中，打开命令面板的“帮助&amp;gt;显示所有命令”。 或者使用键盘快捷方式 (Ctrl+Shift+P) Go: Install/Update tools搜索，然后从托盘运行命令 出现提示时，选择所有可用的 Go 工具，然后单击“确定”。 等待 Go 工具完成更新。 5. 编写示例 Go 程序 在Visual Studio Code中，打开将在其中创建 Go 应用程序的根目录的文件夹。 若要打开文件夹，请单击活动栏中的“资源管理器”图标，然后单击“ 打开文件夹”。 单击“资源管理器”面板中的“ 新建文件夹 ”，然后为名为“Go”的示例应用程序创建根控制器 sample-app 单击资源管理器面板中的“ 新建文件 ”，然后为文件命名 main.</description>
    </item>
    
    <item>
      <title>微信to-淘宝</title>
      <link>https://fabletang.github.io/en/posts/2023-04-14-tbtest/</link>
      <pubDate>Fri, 14 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2023-04-14-tbtest/</guid>
      <description> 此h5只是验证lulu技术可行性，点击 http://vip100.ltd/Qt0vVjBc 相当于下图立即购买按钮 此h5只是验证lulu技术可行性，点击 https://m.tb.cn/h.UsUePG8 相当于下图立即购买按钮 [1] youjiangaoshan [2] lulu </description>
    </item>
    
    <item>
      <title>Golang GMP调度</title>
      <link>https://fabletang.github.io/en/posts/2021-12-06-golang_gmp/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2021-12-06-golang_gmp/</guid>
      <description>一、GMP “调度器” 的由来 单进程时代不需要调度器 早期的操作系统每个程序就是一个进程，直到一个程序运行完，才能进行下一个进程，就是 “单进程时代”.自动化控制中的PLC也是典型的单进程操作系统。
多进程 / 线程时代有了调度器需求 典型的操作系统unix/linux,对进程/线程进行了管理。
goroutine是比线程更轻量级的协程 goroutine是golang独有的概念,是为了更少的内存和cpu开销，比线程更加轻量，可以看作是线程的&amp;quot;son&amp;quot;.很明显操作系统管理不了，所以出现了GMP.
二、GMP 定义 G=goroutine,M=mechine,P=processor. 三、GMP 模型 在 Go 中，线程(M)是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上。 全局队列（Global Queue）：存放等待运行的 G。 P 的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G时，G优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。 P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。 M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。 三、GMP 设计策略 复用线程：避免频繁的创建、销毁线程，而是对线程的复用。
work stealing 机制</description>
    </item>
    
    <item>
      <title>并发与并行</title>
      <link>https://fabletang.github.io/en/posts/2021-12-06-concurrency_parallelism/</link>
      <pubDate>Mon, 06 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2021-12-06-concurrency_parallelism/</guid>
      <description>为了让程序更好地利用计算机资源，出现了进程/线程，以及并发模式和并行模式的概念。
一、进程和线程 A. 进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。 B. 线程是进程的一个执行实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位。 C. 一个进程可以创建和撤销多个线程;同一个进程中的多个线程之间可以并发执行。 二、并发和并行 A. 多线程程序在一个核的cpu上运行，就是并发。 B. 多线程程序在多个核的cpu上运行，就是并行。
如图所示: 三、并发和并行的效率比较 如上图所示，假定任务A/B/C均衡分配，并行效率更高，因为并发切换线程需要cpu开销(图中树立的双虚线)。
但是为什么绝大多少操作系统，应用程序采用并发的机制呢？因为并行和并发是以CPU来区分，大多数场景下，需要磁盘IO、网络IO，这些IO耗时远远大于cpu耗时,所以大部分情况下并发更能充分利用计算机资源。超级计算机，比如银河超级计算机，这类计算机专注于CPU计算，所以采用并行的操作系统和程序。
四、协程和线程 随着互联网的发展，C10k问题（即单机 10000 个并发连接）出现了。CPU硬件发展不能再遵守摩尔定律,1万个线程切换的耗时变得不能承受.操作系统层面，采用epoll类似的IO多路复用技术来减少线程数.
golang在语言层面采用goroutine协程减少线程开销。
协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。 线程：一个线程上可以跑多个协程，协程是轻量级的线程，多数情况下，每个线程至少需要占用内存1MB。 每个goroutine协程2KB的栈内存占用, 采用GMP机制管理. </description>
    </item>
    
    <item>
      <title>vim 文件相关(四)</title>
      <link>https://fabletang.github.io/en/posts/2021-11-30-vim_file/</link>
      <pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2021-11-30-vim_file/</guid>
      <description>一、vim 文件管理相关 插件: &amp;#34; 文件管理插件 Plug &amp;#39;preservim/nerdtree&amp;#39; Plug &amp;#39;Xuyuanp/nerdtree-git-plugin&amp;#39; &amp;#34; 历史文件增强 :browse oldfiles Plug &amp;#39;gpanders/vim-oldfiles&amp;#39; 配置: &amp;#34; NERDTree插件的快捷键 nn &amp;lt;silent&amp;gt; &amp;lt;F5&amp;gt; :NERDTreeToggle&amp;lt;CR&amp;gt; &amp;#34;自动启动nerdtree autocmd VimEnter * NERDTree | wincmd p &amp;#34;:browse oldfiles 插件增强 nmap &amp;lt;leader&amp;gt;b &amp;lt;Plug&amp;gt;(Oldfiles) &amp;#34; F2 通过打开的文件对齐树形目录 nn &amp;lt;silent&amp;gt;&amp;lt;F2&amp;gt; :exec(&amp;#34;NERDTree &amp;#34;.expand(&amp;#39;%:h&amp;#39;))&amp;lt;CR&amp;gt; &amp;#34; Check if NERDTree is open or active,打开的文件自动定位目录 function! IsNERDTreeOpen() return exists(&amp;#34;t:NERDTreeBufName&amp;#34;) &amp;amp;&amp;amp; (bufwinnr(t:NERDTreeBufName) != -1) endfunction &amp;#34; Call NERDTreeFind iff NERDTree is active, current window contains a modifiable &amp;#34; file, and we&amp;#39;re not in vimdiff function!</description>
    </item>
    
    <item>
      <title>vim 窗口相关(三)</title>
      <link>https://fabletang.github.io/en/posts/2021-11-30-vim_windows/</link>
      <pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2021-11-30-vim_windows/</guid>
      <description>一、vim 窗口类别 1.文本窗口: 主窗口，文本区。
2.buffer窗口: vim运行期间的缓冲文件列表。关闭后清零。 打开: &amp;ldquo;:ls&amp;rdquo; 关闭: &amp;lt;ESC&amp;gt;或者选择一个文件序号自动关闭 3. quickfix窗口: 运行结果显示等。也有插件利用这个窗口显示文件列表。 打开: &amp;ldquo;&amp;lt;leader&amp;gt;o&amp;rdquo;,此快捷键参照配置文件定义。 &amp;lt;leader&amp;gt;为&amp;quot;,&amp;quot; 关闭: 按提示&amp;lt;CR&amp;gt;回车，或者 &amp;ldquo;&amp;lt;leader&amp;gt;oo&amp;rdquo;. 参照配置文件。 &amp;lt;leader&amp;gt;配置:
&amp;#34; like &amp;lt;leader&amp;gt;w saves the current file let mapleader = &amp;#34;,&amp;#34; let g:mapleader = &amp;#34;,&amp;#34; 4. nerdtree窗口: nerdtree插件非常流行，用来文件管理。
&amp;#34; NERDTree插件的快捷键 nn &amp;lt;silent&amp;gt; &amp;lt;F5&amp;gt; :NERDTreeToggle&amp;lt;CR&amp;gt; 打开/关闭: &amp;lt;F5&amp;gt;切换,一般配置为自动打开。 退出: 切换到nerdtree窗口然后&amp;quot;q&amp;quot; 二、vim 窗口切换: 见配置,ctrl键盘+jkhl:
&amp;#34; Smart way to move between windows map &amp;lt;C-j&amp;gt; &amp;lt;C-W&amp;gt;j map &amp;lt;C-k&amp;gt; &amp;lt;C-W&amp;gt;k map &amp;lt;C-h&amp;gt; &amp;lt;C-W&amp;gt;h map &amp;lt;C-l&amp;gt; &amp;lt;C-W&amp;gt;l </description>
    </item>
    
    <item>
      <title>vim 配置(二)</title>
      <link>https://fabletang.github.io/en/posts/2021-11-24-vim_conf/</link>
      <pubDate>Wed, 24 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2021-11-24-vim_conf/</guid>
      <description>一、vim安装插件管理器 早期的vim插件需要在网站下载，然后复制到对应目录.（https://www.vim.org/scripts/index.php)
受益于github的发展，用插件管理器(一般使用plug.vim)可以批量自动安装和更新插件。非常方便。
git clone https://github.com/junegunn/vim-plug ,然后复制 plug.vim 到vim目录下的 autoload目录就完成了。
二、vim配置文件 1.vimrc位置目录 vimrc是vim的总配置文件,windows下为vimrc,linux/macos为.vimrc。
一般位于$HOME目录。启动vim,命令行输入:echo $HOME，就可以显示。在此目录下建立vimrc或者.vimrc文件。
2.vimrc内容 此配置适用macos,其他系统需要少量适配，如果不使用golang,对应插件用&amp;quot;号注释就可以。
配置中有简要说明.详细介绍请参考github或者本blog其他文章。
filetype off &amp;#34; required syntax on &amp;#34;安装 plug插件管理器 &amp;#34;curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim &amp;#34;然后运行:PlugInstall ,如果遇到下载失败按键R重新执行 call plug#begin(&amp;#39;~/.vim/plugged&amp;#39;) Plug &amp;#39;fatih/vim-go&amp;#39; Plug &amp;#39;buoto/gotests-vim&amp;#39; Plug &amp;#39;maralla/completor.vim&amp;#39; Plug &amp;#39;preservim/tagbar&amp;#39; &amp;#34; 快速注释,自动检测语法 Plug &amp;#39;preservim/nerdcommenter&amp;#39; &amp;#34; 文件管理插件 Plug &amp;#39;preservim/nerdtree&amp;#39; Plug &amp;#39;Xuyuanp/nerdtree-git-plugin&amp;#39; &amp;#34;Plug &amp;#39;ryanoasis/vim-devicons&amp;#39; &amp;#34;git状态显示 Plug &amp;#39;airblade/vim-gitgutter&amp;#39; &amp;#34;Plug &amp;#39;mhinz/vim-signify&amp;#39; &amp;#34;文件查找 Plug &amp;#39;kien/ctrlp.vim&amp;#39; &amp;#34;文本搜索 Plug &amp;#39;dkprice/vim-easygrep&amp;#39; &amp;#34;颜色风格 Plug &amp;#39;tomasr/molokai&amp;#39; &amp;#34;括号自动补全 Plug &amp;#39;Townk/vim-autoclose&amp;#39; &amp;#34;Plug &amp;#39;Valloric/YouCompleteMe&amp;#39; &amp;#34;代码模版快速生成 Plug &amp;#39;SirVer/ultisnips&amp;#39; Plug &amp;#39;honza/vim-snippets&amp;#39; &amp;#34;代码自动补全 Plug &amp;#39;Shougo/neocomplete.</description>
    </item>
    
    <item>
      <title>vim 入门(一)</title>
      <link>https://fabletang.github.io/en/posts/2021-11-22-vim_tutor/</link>
      <pubDate>Mon, 22 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2021-11-22-vim_tutor/</guid>
      <description>一、vim起源 vim至今30年历史了，vim是&amp;quot;Vi Improved&amp;quot;的缩写，由vi发展而来.
vi是unix系统默认编辑器，当时没有鼠标，键盘的按键也较少，比如方向键/Cap等就没有。所以当时的人们(主要是贝尔实验室)创造一个纯键盘的文字编辑器。意外的是，经过几十年的验证，纯粹键盘操作比居然比鼠标更加便捷高效。
甚至有vim狂热喜爱者喊出口号：世上的编辑器分两种，一种是vim，一种是其他。^_^
二、vim介绍 以下vim默认为vim8.1+版本。
1.vim界面 通常的vim界面如下图。左边是文件列表(nerdtree插件效果)，右底下是quickfix区域，一般显示查找运行结果/查找结果列表之类。右边面积最大的为文本编辑区。 2.vim模式 模式是为了让vim知道当前的按键是文本输入还是其他操作功能(光标移动/标签等等).常用四种模式,如下图。
可以观察到，任何情况下，按esc键就回到普通模式了。所以esc键使用频率非常高（甚至有人专门发明esc脚踏板）。 三、vim学习 1.vim安装 建议安装GUI图形界面的vim,文本渲染比控制台下的要快一点。
windows: https://www.vim.org/download.php#pc macos: https://github.com/macvim-dev/macvim/releases 2.vim练习 网上有大量vim入门教程，但是建议用vim自带的vimtutor学习。vim键盘命令非常多，死记硬背是比较难的，结合教程，在使用中记忆，让肌肉形成条件反射。3-5天就比较熟练了。在控制台(console)提示符下，输入vimtutor,或者vim命令模式下:vimtutor,注意键盘要切换为英文小写。如下图: 四、vim常用键盘命令图 </description>
    </item>
    
    <item>
      <title>Golang介绍</title>
      <link>https://fabletang.github.io/en/posts/2021-11-18-introduce_of_golang/</link>
      <pubDate>Thu, 18 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2021-11-18-introduce_of_golang/</guid>
      <description>目前golang最新版本为1.17.3，经过12年的发展，生态已经成熟。
Go是一门工程语言 go诞生的初衷就是解决c/c++的各种弊端，提高生产力。
go编译速度极快，相对于c++/rust,10倍以上编译速度。 go fmt 代码格式化,代码风格统一。 自动垃圾搜集。简化c/c++的内存管理。 单一执行文件。 Go与其他语言的区别 Go vs Java: Go有内存垃圾自动处理，无虚拟机。 Go无对象编程的类class的概念，更强调struct（类似C）. Go的对象继承是“鸭子原理&amp;quot;,Java是“血缘关系&amp;quot;. Go vs C: Go无宏定义.兼容C。基本上可以用C的风格来写Go代码。 Go vs C++: C++ 20是一门现代语言，有非常多的特性，Go语言是以C为参考的，所以大多数特性Go都不具备，比如虚函数等。 Go vs Rust: Rust是在Go诞生后出现的，Go语法简单，Rust语法复杂。Rust强调严格的内存安全，Go的自动垃圾搜集是宽松的内存管理。Rust具备大多数现代语言特性，其复杂性与C++相当。 Go vs javascript/typescript/php: Go 是强类型语言，性能高很多。 Go的优势 语法简洁 简洁不意味简单，但是编码效率高,清晰易懂也减少维护成本。 性能优异 性能介于c++/rust 与 Java之间。2倍以上java性能。 生态丰富，开发效率高 基础类库多,经过12年的发展，驱动/扩展库也多 开发工具成熟,包管理go mod,编程IDE:goland/vscode/vim-go 开发资料丰富，常见问题大部分已经可以baidu/google. 建议掌握的编程要点 多值返回 函数式编程 单元测试 goroutine sync channel reflect context库 web框架gin Generic泛型(go 1.18) ORM框架 gomybatis log组件 zap 配置组件 viper </description>
    </item>
    
    <item>
      <title>元宇宙的一些判断</title>
      <link>https://fabletang.github.io/en/posts/2021-11-11-metaverse/</link>
      <pubDate>Thu, 11 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2021-11-11-metaverse/</guid>
      <description>最近“元宇宙&amp;quot;炒的火热，随着facebook公司改名为meta以后更是达到了高潮。 元宇宙英文原词“Metaverse”，出自尼尔·斯蒂芬森1992 年的科幻小说《雪崩》， 在这部小说中讲述了大量有关虚拟化身、赛博朋克等场景。 可以简单认为是VR虚拟现实的进化版,虚拟现实只是暂时进入，而元宇宙是具备独立意识的第二生命空间。
最近《三体》作者强烈反对“元宇宙”，他认为这是个错误的道路，应该实体探索星空。 我赞同他的呼吁，但是元宇宙很难避免,必然出现，恐怕最好的结果是原宇宙中的意识去探索星空。
大胆给出以下观点:
元宇宙将出现，届时实体人类将灭亡。 元宇宙需满足以下条件: 人工智能已经实现。 智能生命相关伦理和法规成熟。 能源无尽，人类基本生活需求已经满足。 人工智能20年以内都难以实现，元宇宙更将遥遥无期，至少看到这篇文章的你,有生之年希望渺茫。 为什么元宇宙必然出现: 人性角度 人是欲望的集合体，欲望是生存的支柱。脱离肉体，欲望更有放飞的空间。大部分人连游戏/赌博/旅游/购物这样的满足感都抵御不了，怎么能抵抗梦里成真的诱惑？怎么能抵抗永生的诱惑?
为什么元宇宙出现后人类将灭亡: 可以参考电影《黑客帝国》
人性角度 假如元宇宙的人也具备人性，当元宇宙的你知道可以被现实世界的你摧毁，会发生什么？谁更可能取胜？不同于电影的英雄主义宣传，我悲观认为在这个新的黑客帝国，智能生命将取胜。
物种角度 假如元宇宙的人是独立的智能生命,他们将形成新的种族或者阶级，这样的团体会认为虚弱、智力低下的现实人类是同一种族吗？现实社会的你会喜欢吸血的臭虫吗？
元宇宙需要很强大的技术基础,很长时间内都难以满足: 内容如此丰富的元宇宙，很难想象没有强大的人工智能在维护。 现在的AI技术是很低级的，物品识别都有较大错误率(参见自动驾驶)，智能推断更是呆板(参见军用无人机)。 再往前考察所需技术，3D实时成像。3D实时成像的物理基础不存在， 2016的VR泡沫破灭，是因为最强大的显卡制造商Nvidia宣布不生产便携式的眼镜大小的显卡,显然当时是技术达不到。即使到2021年末的今天，显示卡的性能还是达不到，Nvidia还是没生产或者研发这种实体小、性能强、功耗少的显示卡。 3D实时成像从软件上来看也是行不通，目前的图形渲染技术的基本元素是三角形,要达到接近现实的效果，需要以像素点来渲染，然而这样的图形渲染算法目前都没有应用。 交互技术不成熟, 目前玩游戏用的是键盘和鼠标/触摸板以及麦克风。显然做不到逼真、实时的交互。 再往低层技术考察，操作系统。目前最先进的应该是linux. 但是这个每年都能发现0day bug的系统能承载一个虚拟世界？现在根本没有千万人在同一服务器的游戏。 继续往低层技术考察，编程语言还处于争论阶段，目前还没有一种效率高、难度低、安全高的语言。rust?语法还在变化，特性还在频繁增加的语言能叫成熟？rust能写操作系统吗? rust语言的难度甚至超过c++. </description>
    </item>
    
    <item>
      <title>关系型数据库实践</title>
      <link>https://fabletang.github.io/en/posts/2021-11-09-practice_of_db/</link>
      <pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2021-11-09-practice_of_db/</guid>
      <description>关系型数据库是绝大多数系统的数据核心,这个关键设施也往往是性能的瓶颈。以下是一些使用建议。
按业务场景设计表结构 业务场景: 一个mysql的用户表，1000万条记录，如何查询出当天生日的用户？
表结构通用规则 所有字段必须非空而且有默认值。 一般都有创建时间和更新时间字段，mysql5.6+ 支持数据库本身更新此字段。 尽可能不使用TEXT、BLOB类型. 表字符集尽量选择UTF8MB4,mysql的utf8不是标准的字符集，utf8mb4可以存储表情字符。 索引字段尽可能使用int/long, 索引为字符型不能超过32个字符。 注释尽量清楚 建表的时候应该考虑最终的数据量，mysql单表应该不超过1000万,分布式数据库按业务字段分区。 不使用外键，尽量少用联合唯一束缚。联合主键酌情使用。 查询最佳实践 互联网业务场景,数据库瓶颈一般出现在查询。
查询一般不关联超过3个表。 查询扫码记录数超过10万条，必须命中索引。 避免使用inner join，left join 语句中的主表应该是结果数据量最少的表。 where语句最左原则，最靠近where的条件应该是索引，应该是可以最大限度缩小查询范围的条件。 避免破坏索引的不规范语句，比如id=&amp;lsquo;1&amp;rsquo;,类型转换会忽略索引,比如 like %xxx%,模糊匹配也会破坏索引。 尽量少用数据库特殊函数，影响性能也不好迁移。 尽量少用group by/max/sum,如果是高频调用的sql, 意味着表结构不合理。 禁止使用 select *，不知道需要返回的字段，意味着不理解业务。 通用最佳实践 查询语句复杂，往往是缺状态字段或者缺统计表。 应该手写sql,反对使用所谓面向对象的orm中间件，比如hibernate,mybaits-plus。 单个api的sql语句一般不超过3条。 3次以上数据库交互，响应速度就很差。 读写分离,实时性要求不高的查询，应该走从库。互联的mysql 一般是1主3+从. 数据强一致,并且并发高的情况下(间隙锁)，事务提交不能解决问题的话，考虑乐观事务(version字段)以及分布式全局锁（redis/zookeeper） </description>
    </item>
    
    <item>
      <title>技术管理-管理、人性与OKR</title>
      <link>https://fabletang.github.io/en/posts/2021-04-22-methodology_2/</link>
      <pubDate>Thu, 22 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2021-04-22-methodology_2/</guid>
      <description> 管理 一、管理的历史 奴隶社会 封建社会 现代社会 工业：流水线\六西格玛\丰田管理(看板) 软件开发： 瀑布式\快速迭代\XP极限编程\scrum敏捷开发 二、人性 三字经，人之初，性本善。 三、OKR </description>
    </item>
    
    <item>
      <title>java模式:单例/多例/线程单例</title>
      <link>https://fabletang.github.io/en/posts/2021-02-26-java_singleten_pattern/</link>
      <pubDate>Fri, 26 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2021-02-26-java_singleten_pattern/</guid>
      <description>java单例模式有5种实现方式,推荐以下3种方式. 一、单例-饿汉式: 特点:线程安全，不能延时加载
public enum SingletonDemo1 { //枚举元素本身就是单例 INSTANCE; //添加自己需要的操作 public void singletonOperation(){ } } 二、单例-懒汉式-双重锁检查: 特点:线程安全，延时加载。 ps: java1.5后,volatile可以避免jvm初始化内存分配可能乱序的问题。
public class SingletonDemo2 { private static volatile SingletonDemo2 SingletonDemo2; private SingletonDemo2() { } public static SingletonDemo2 newInstance() { if (SingletonDemo2 == null) { synchronized (SingletonDemo2.class) { if (SingletonDemo2 == null) { SingletonDemo2 = new SingletonDemo2(); } } } return SingletonDemo2; } } 三、单例-懒汉式-静态内部类: 特点:线程安全，延时加载。
public class SingletonDemo3 { private static class SingletonClassInstance{ private static final SingletonDemo3 instance=new SingletonDemo3(); } private SingletonDemo3(){} public static SingletonDemo3 getInstance(){ return SingletonClassInstance.</description>
    </item>
    
    <item>
      <title>技术管理-怎么学</title>
      <link>https://fabletang.github.io/en/posts/2021-02-17-methodology_1/</link>
      <pubDate>Wed, 17 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2021-02-17-methodology_1/</guid>
      <description> 很多技术人不喜欢管理，就像古代书生怕碰到铜钱，沾染了“铜臭”变得不纯洁了。 管理，第一是对自我的管理,自己的工作方式。不要把管理想象成奴役他人的皮鞭，可以认为管理首先是规范自己的 戒尺，然后把这根戒尺变成指挥棒去协调团队。 某些同学看了这些书，甚至考试认证都过了，还是没找到管理的感觉。 今天跟大家探讨一下，怎么学习管理理论。 一、学习的广度 站在巨人肩膀上做事是理所当然的，所以管理相关的理论知识要先学习。这方面的权威书籍有很多， 比如国家软件项目管理考试、国际pmp项目管理认证,都是很好的教材，这些教材每年都有更新，比如scrum都包含在内。 网络上有最新的管理方法，比如OKR.这些也需要了解,现在信息交流快捷，几年就会变换一种主流管理方法。 二、学习的深度 理工科毕业的技术人讲究“实证&amp;quot;,对书本上泛泛而论的管理方法很难产生共鸣，自己都不信的理论，当然就很难在 实际工作中运用。 但是我们可以采用数理的逻辑来印证管理理论: 比如“过程管理&amp;quot;,很多管理方法都提到这个词，为什么一定要“过程管理“解释得并不通透， 如果联系到理工科都学过的“工业自动化”的“闭环反馈&amp;quot;就容易明白了。 又比如“扁平式组织结构”，如果联系到 “信息论&amp;quot;里的“任何信息传递、转换都会有损耗”, 就很容易理解层级少的组织可以减少沟通成本。 三、以人为本 管理是对人的规则。 人是不一样的，同样的人在不同时期也是不一样的。所以大家可以观察到主流管理方法会随时间 而淘汰，不同行业的主流管理方法也不一样。体察人性，与对应的管理方法对应起来，深刻领会原因, 这样就会&amp;quot;相信&amp;quot;, 只有你“信”，才能影响他人。 </description>
    </item>
    
    <item>
      <title>docker tips</title>
      <link>https://fabletang.github.io/en/posts/2017-09-16-docker_tips/</link>
      <pubDate>Sat, 16 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2017-09-16-docker_tips/</guid>
      <description>一、docker rmi: 使用多个images id删除,前四位、空格区分 docker rmi 861b 7d51 过滤批量删除镜像, 对docker images 显示的行进行过滤。 根据tag名删除 docker rmi -f $(docker images | grep &amp;#34;fabletang/test-*&amp;#34; | awk &amp;#34;{print \$3}&amp;#34;) docker rmi -f $(docker images | grep &amp;#34;&amp;lt;none&amp;gt;&amp;#34; | awk &amp;#34;{print \$3}&amp;#34;) 根据版本号删除 docker rmi -f $(docker images | grep &amp;#34;0.0.1&amp;#34; | awk &amp;#34;{print \$3}&amp;#34;) 根据Tag和版本号删除 docker rmi -f $(docker images | grep &amp;#34;fabletang/service-java&amp;#34; | awk -F&amp;#39; 0.&amp;#39; &amp;#39;{if ($2&amp;lt;0.6) print $0}&amp;#39; | awk &amp;#34;{print \$3}&amp;#34;) 删除所有未运行 Docker 容器 docker rm $(docker ps -a -q) </description>
    </item>
    
    <item>
      <title>docker私有仓库搭建</title>
      <link>https://fabletang.github.io/en/posts/2017-09-01-docker_registry/</link>
      <pubDate>Fri, 01 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2017-09-01-docker_registry/</guid>
      <description>环境:centos7,docker 1.12+，registry 2.
一、准备工作: mkdir /data/docker-registry mkdir /data/docker-registry-auth 二、安全设置: 生成 http 密码文件
docker run --entrypoint htpasswd registry:2 -Bbn anycloud &amp;#39;123&amp;#39;&amp;gt; /data/docker-registry-auth/htpasswd 获取 SSL 证书 git clone https://github.com/letsencrypt/letsencrypt cd letsencrypt ./letsencrypt-auto --help ./letsencrypt-auto certonly --standalone -d &amp;lt;HOST&amp;gt; 三、启动: 新增systemd守护服务,内容如下
cat /etc/systemd/system/multi-user.target.wants/docker-registry.service [Unit] Description=registry Requires=docker.service After=docker.target [Service] Restart=always RestartSec=20 TimeoutStartSec=5min ExecStartPre=-/usr/bin/docker kill registry ExecStart=/usr/bin/docker run -p 5000:5000 --name registry \ -v /data/docker-registry-auth/:/certs \ -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/fullchain.pem \ -e REGISTRY_HTTP_TLS_KEY=/certs/privkey.pem \ -e REGISTRY_STORAGE_DELETE_ENABLED=true \ -v /data/docker-registry-auth/:/auth \ -e &amp;#34;REGISTRY_AUTH=htpasswd&amp;#34; \ -e &amp;#34;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&amp;#34; \ -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \ -e REGISTRY_STORAGE_DELETE_ENABLED=true \ -v /data/docker-registry/:/var/lib/registry \ registry:2 ExecStartPost=-/usr/bin/docker rm registry ExecStop=/usr/bin/docker stop registry ExecStopPost=-/usr/bin/docker rm registry [Install] WantedBy=multi-user.</description>
    </item>
    
    <item>
      <title>Golang代码结构</title>
      <link>https://fabletang.github.io/en/posts/2017-05-01-the_struct_of_go_project/</link>
      <pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2017-05-01-the_struct_of_go_project/</guid>
      <description>Go的设计思想是代码至上，依赖于代码而不是象其它语言依赖于编译好的库。尽管go的版本号已经到1.8.1了,但是还没没有好的package版本管理策略。1.6推出的vender只是稍微缓解了困境,只有寄希望与将来的1.9版本了。Go的代码结构不同于其它语言的地方,以java为对照:
代码文件位于src目录 假如GOPATH对应项目goprojectstruct,代码文件应该处于 goprojectstruct/src目录内.
Go无class的概念 Go无对象编程的类class的概念。所以代码文件名称可以随意定义，但是一般位于package目录,一般与package同名，但是拆分成几个文件也是可以的。
代码文件/package名为小写 Java文件名一般为大写。Go以简单为宗旨，显然小写字母要简单,也符合go的定义，小写代表私有private，大写代表公开public。
单元测试文件 单元测试文件与被测试文件处于同一目录，文件名追加&amp;quot;_test&amp;quot;,比如 hello.go的测试文件为 hello_test.go.
引用库位于vender 所有外来引入的package都应该处于vender目录下。.gitignore也应该忽略vender目录。以此保持代码结构的精简。
package版本管理 在go1.9之前，推荐采用glide来管理。</description>
    </item>
    
    <item>
      <title>微服务的粒度</title>
      <link>https://fabletang.github.io/en/posts/2017-04-01-granularity_of_microservice/</link>
      <pubDate>Sat, 01 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2017-04-01-granularity_of_microservice/</guid>
      <description>得益于nginx等反向代理的流行以及metrics/endpoit规范的成熟。微服务的理念开始流行了。 但是微服务究竟要多&amp;quot;微&amp;quot;才合适？以下是我的个人实践。
不能按接口分: 这样的粒度太细.比如新增订单/查询订单分为两个microservice,优点是可以根据各自的负载合理分配服务器 资源。缺点是microservice数量过多，这样拆分的话，至少存在几十个service，这样对service的依赖关系，监控 ／部署都增加很大的难度。
不能按数据库表名(table)分: 这是个鲁莽的做法。很明显，数据库的的事务处理将极为棘手。
不能按数据库名(db)分: 这样的粒度太粗.好处是本地数据库数据一致性问题很好解决。缺点是功能过于集中，不利于后期改进。
建议按子业务分，同时考虑数据库表的关联: 比如按订单/用户管理这样的粒度分，数据库表相对独立。这样service的数量较为合适，语意上也容易理解。</description>
    </item>
    
    <item>
      <title>stateless server 最佳实践</title>
      <link>https://fabletang.github.io/en/posts/2017-01-01-stateless_server/</link>
      <pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2017-01-01-stateless_server/</guid>
      <description>stateless server 即无状态服务。相对与传统的http server存在session,无session的 http server称为stateless server，现在一般应用于restful service.
Why: session的概念存在这么多年，一定有其合理之处,为什么要抛弃它?
session的起源: session根源于http的cookie. http协议本身是无状态的协议，server是一问一答，答后不管。为了加入 状态，来辨识是否访问／是否登录的需要，加入了cookie。服务器的session就是对应浏览器端的cookie.
为什么抛弃session:
高并发的访问，session制约了server的水平扩展。在负载均衡的多个server群，虽然可以用高速缓存比 如redis来管理全局session.但是毕竟多存在了一个节点，削弱了系统稳定性。
session需要资源开销，在tomcat中，每个session至少耗费4k内存。
session存在安全缺陷，一般session会以明文形式写入cookie,cookie是保存在浏览器端的硬盘，由此引发 的安全问题可以写成一本书了。即使禁用cookie, session也容易被窃取，CSRF跨域攻击就是窃取session的 安全问题。
随着server的功能增多，有时候需要跨域访问的时候，session成为了障碍。比如网页需要访问两个服务器的 资源，而且都必须要要登录授权保持状态,这样需要两个sessionid,但是浏览器只支持单一session.
What: stateless server是否就是服务器不需要state状态？ 需要授权的资源如果不保存其状态，比如用户id／角色。每次访问都要重新提交验证信息。服务器可能要重复 验证／查询数据库,这样会带来额外的资源开销。 所以，stateless应该理解为服务器不保存状态。
How: server需要状态，但是不保存状态。怎么做？ 采用jwt,状态保存在客户端。jwt 即json web token. server 把状态放入jwt,加密，以字符串的方式发送给客户端。
采用jwt的好处:
可以封装状态，以key／value字符的形式保存状态。 安全。jwt一般采用对称或者非对称加密。加密密钥存放在server.可以防止jwt被篡改。jwt同时有时效性，合适的有效期可以减少重放攻击的可能性。 </description>
    </item>
    
    <item>
      <title>关于软件项目计划的看法</title>
      <link>https://fabletang.github.io/en/posts/2015-10-06-project-schedule/</link>
      <pubDate>Tue, 06 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2015-10-06-project-schedule/</guid>
      <description>&amp;ldquo;凡事预则立 不预则废&amp;rdquo;,这是&amp;laquo;礼记&amp;raquo;中的名言,意思是任何事情不作计划就会失败。
软件项目也一样必须作计划。但是实际情况是，软件项目很难预估资源和时间。软件开发中
有个“公理”：20%的工作要花费80%的时间。二八原理。还有一个&amp;quot;20%的项目是成功，80%&amp;quot;
将失败&amp;quot;。说明软件项目很难作出贴近实际的计划(schedule)。Why?
特性: 软件项目大多是创造性，难度大，复杂程度高。就单单编程语言来说，在电脑领域已发 明了上千不同的编程语言，而且每年仍有新的编程语言诞生。
资源: 软件项目的主要资源:人,是稀缺的。需要较高技能要求。</description>
    </item>
    
    <item>
      <title>Grails框架介绍</title>
      <link>https://fabletang.github.io/en/posts/2014-12-25-grails_intro/</link>
      <pubDate>Thu, 25 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2014-12-25-grails_intro/</guid>
      <description>Grails是一套用于快速Web应用开发的开源框架，它基于Groovy编程语言，并构建于Spring、Hibernate等开源框架之上，是一个高生产力一站式框架。其官方网站上的煽情介绍为：The search is over!, 即为不要再苦苦寻找web开发框架了，Grails是终结者。
如果web项目组大部分懂java，又没有旧的web项目负担。Grails是明智的选择。 缺点: groovy是类java的脚本解释动态语言，尽管其兼容java所有语法，最终也运行于JVM,但是速度有所影响.总体grails 比rails快，慢于传统ssh(struts/spring/hiberate)框架. 除了稍慢的运行速度，grails相对SSH全面胜出，以下是论点:
一、学习成本低: groovy语法不用学习，如果懂得java,groovy就是秒懂，实在不行，完全用java的语法也没有任何问题。其实注重运行速度的功能，比如加密解密，数据排序等算法推荐用java编写，groovy可以无缝引用。 grails的springframework\hibernat极易使用，基本不用学习，完全不用理会那些迷宫式xml配置。grails会自动帮你处理好。 二、开发速度快: grails 不是粗糙的ssh,它甚至有命令控制台，比如 grails create-control abc.login,就自动创建好了control及相关的测试文件。不用手动建立目录，建立文件。 调试便捷，run-app命令就可以运行一个web服务器，不需要启动额外的tomcat或者其他web容器, 同时它还是热编译的，也就是说，运行期间，你改动代码，grail自动就编译好了，不需要重新启动，哪怕你改动control都可以。 3.groovy语言大大减少了java的繁杂，同时集成很多通用库，可以大大减少代码. 三、功能完善: ssh是个粗糙的框架，不怀疑可以很快写出一个CURD的功能块。但是这远远不能应付实际项目需求，还得做大量的工作。
view层： grails 集成了sitmesh模版，而且自动加载缓存，模块化view。GSP相对structs的标签更好用。
control层: view数据绑定支持list,可以实现多维数据结构。spring mvc只支持map/bean 键值绑定方式。数据渲染很容易实现json/xml输出。比如 render xxxxbean as JSON
model层: 易于处理多对多，一对多，级联删除，完全不用去配置hibernat XML. 脏数据处理，数据缓存默认集成。
测试功能完备，易于使用，m/v/c各层都容易实现测试.
其他小功能完备，比如内置一个内存数据库，项目发布时候无缝切换实际数据库。
四、项目易于管理: Grails 的原则是约定大于配置，也就是说配置文件，文件目录，命名方式都是约定好的。开放人员就是做填空题。项目自然就规范了。 Grails大大减少了配置文件，groovy语法大大缩减了代码量，越少的编码意味更好维护。 Grails开发模式下的热部署功能给前端开发提供很大便利，可以不重启web容器就可以即使得到改动的效果。这样利于前端后端开发分工。 </description>
    </item>
    
    <item>
      <title>养金鱼</title>
      <link>https://fabletang.github.io/en/posts/2014-10-19-goldfish/</link>
      <pubDate>Sun, 19 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2014-10-19-goldfish/</guid>
      <description>鄙人喜欢狗，对养鱼这种雅趣向来不屑一顾。几个月前儿子笑盈盈地提着一个透明小水盒，
得意的炫耀他钓的金鱼。原来是公园的付费小娱乐，每次十元，规定时间内钓的金鱼就可以
带回。我瞅了瞅，6条小金鱼，不是锦鲤，也不是那种鱼鳍眼睛特别大的金鱼，就是鱼鳍比一般
鲤鱼大一点，颜色更鲜艳的金色小鲤鱼, 不是什么名贵品种。似乎刚被勾上来，神情恹恹，浮在
透明塑料小盒子里。看来没几天好活，不忍心打击儿子的童心，便答应养着。
一个星期后，死了一条，剩下5条居然活了下来，使劲游水，已经适应了环境。就多留意了一些，
晚上睡觉的时候，也偶尔听到小鱼吧嗒水泡的声音，似乎是小水盒太挤，氧气不足,所以游在水面
上吐泡泡。
又过了大半个月，5条金鱼没减员，而且更见活泼。每次投食都聚集过来吐泡泡，拼命摆动尾巴。
好吧，毕竟是5条生命，既然安了家，就一起生活吧。催着家人去菜市场买个大点的鱼缸。
几天后，金鱼就快活的游在一个椭圆形的玻璃缸里，后来听人说水草能改水质, 就买了几根鞭子
一样的水草，但是没多久叶子就被啃光了。 每天早晚两次投食，应该没这么饿吧。跟人交流，对方
也是惊诧, 我嘴里说着这鱼是个吃货，心里居然有小小的得意。
后来那个小的椭圆形玻璃缸，因为每3天要换水，不小心磕坏了。
现在是一个20cm20cm20cm的小鱼缸(家里太小),安装了一个2w的过滤器，水流冲下来带来小气泡，
兼任加氧的功能。不打算用那种自动偷食，光照，加氧，调温，过滤的专业鱼箱。又讨来几个石螺，
帮忙清理排泄物。这样就不用3天整个换水了，一周换几杯水就够了。
每次靠近鱼箱，小家伙们就凑过来，拼命吐泡泡，摇尾巴。看来以后要一起生活了。 ^_^</description>
    </item>
    
    <item>
      <title>Gradle 介绍</title>
      <link>https://fabletang.github.io/en/posts/2014-10-13-introduce-gradle/</link>
      <pubDate>Mon, 13 Oct 2014 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2014-10-13-introduce-gradle/</guid>
      <description>gradle 现在已经2.1版本了。从1.0版本就一直关注这个groovy项目，但是没有应用到
公司项目的打算，但是现在时机到了。gradle已经是最好的java自动构建工具，没有之一。
一、gradle基于动态语言groovy groovy是java的动态版，闭包的特性让其编译脚本更加自由。
比如你可以指定项目的某个目录用特定jdk版本编译。
二、gradle 可以完全利用已有的maven库资源 maven库资源已经发展非常成熟，几乎没有找不到的开源库。
三、gradle插件非常丰富，已经支持android项目构建。 没错，你现在可以用gradle一个命令实现android项目的编译，打包，上传，运行。
插件: com.android.tools.build:gradle:0.13,已经可以胜任任何android项目构建，包括NDK.
Android Studio 0.8.12 已经非常成熟，可以自动生成gradle.build配置文件。
至于普通的java构建，就没有gradle不能做的。
四、gradle学习成本低 gradle学习成本很低，比ant低，比maven低。但是更加强大。</description>
    </item>
    
    <item>
      <title>Android Studio 配置</title>
      <link>https://fabletang.github.io/en/posts/2014-09-30-android-studio-conf/</link>
      <pubDate>Tue, 30 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2014-09-30-android-studio-conf/</guid>
      <description>由于长期在linux下做开发，严重依赖linux的各种小方便，然而需要参与一个Android项目。 项目里有公司开发的.so，涉及了JNI。开始我使用的是eclipse ADT, linux 的usb联机调试也 搞定了，一切似乎都很顺利，usb联机上传也成功了，app出来了，点击，然后就崩溃了，logcat 提示找不到 XXX.so。本来就对eclipse这个老破车有成见，利用这个借口，开始用android studio
环境说明:
Ubuntu /Windows, android studio 0.8.6+
以下是要点：
一、studio 可以直接从eclipse导入,gradle build成功，但是出现编码错误（\78XXX) 这个是编码错误，用笨办法，右键出错文件，enconding GBK, 然后再 UTF-8.
二、编译通过，但是联机调试出现上传错误，提示XX.jar重复copy. 这个是studio本身bug, 在 app下的build.gradle 的 android {&amp;hellip;}内加入
packagingOptions { exclude &amp;#39;META-INF/DEPENDENCIES.txt&amp;#39; exclude &amp;#39;META-INF/LICENSE.txt&amp;#39; exclude &amp;#39;META-INF/NOTICE.txt&amp;#39; exclude &amp;#39;META-INF/NOTICE&amp;#39; exclude &amp;#39;META-INF/LICENSE&amp;#39; exclude &amp;#39;META-INF/DEPENDENCIES&amp;#39; exclude &amp;#39;META-INF/notice.txt&amp;#39; exclude &amp;#39;META-INF/license.txt&amp;#39; exclude &amp;#39;META-INF/dependencies.txt&amp;#39; exclude &amp;#39;META-INF/LGPL2.1&amp;#39; } 三、local.properties 是定义 sdk.dir 和 ndk.dir.需要根据本机andoird jdk情况调整。 四、JNI 相关的问题: android studio 的ndk 不完善，没有eclipse支持那么好。但是也是可以用的，需要在build.gradle
里配置，具体请参看gradle官方文档.
JNI生成的.so打包apk。.so位于 libs/armeabi 目录,在 app下的build.gradle 的 android {&amp;hellip;}内加入</description>
    </item>
    
    <item>
      <title>Ubuntu下Android USB联机调试</title>
      <link>https://fabletang.github.io/en/posts/2014-09-29-android-usb-ubunit/</link>
      <pubDate>Mon, 29 Sep 2014 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2014-09-29-android-usb-ubunit/</guid>
      <description>环境说明: Ubuntu 14.04, android ADT 4.2.2
Linux 下 ADT usb联机调试出现 device unknown 的解决办法:
一、使用lsusb命令查看设备的vendorId和productId。 插入usb线前后用lsusb查看，找出多出的信息。
$ lsusb Bus 003 Device 005: ID 0bb4:0c03 HTC (High Tech Computer Corp.) 二、在/etc/udev/rules.d/目录下面新建一个规则文件 51-android.rules 添加一行 SUBSYSTEM==&amp;#34;usb&amp;#34;,ATTRS {idVendor}==&amp;#34;0bb4&amp;#34;,ATTRS {idProduct}==&amp;#34;0c03&amp;#34;,MODE=&amp;#34;0666&amp;#34; 0666 表示对所有用户，开放adb所有权限
三、 重启usb服务，命令如下： sudo service udev restart 四、 重置ADB 拔下USB与PC连接线，然后再次插上，进入Android-SDK根目录Platform-tools，运行命令:
$which adb $sudo ./adb kill-server $sudo ./adb devices 五、 把adb命令加入环境变量 查找adb所在路径
$which adb 编辑~/.bashrc文件,增加
export PATH=.:$PATH:adb路径 这样就不用每次进入adb目录了。</description>
    </item>
    
    <item>
      <title>%6税率提案</title>
      <link>https://fabletang.github.io/en/posts/2023-06-15-game-eve-tax/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/en/posts/2023-06-15-game-eve-tax/</guid>
      <description>%5联盟统一税率提案 1. 背景 CCP最近实现了 isk和LP的统一税率，据说月底还将实现分别税率。借此机会，NDRC出现了很多高税议案。
EVE军团都有税率，是为了维持军团的基本运营。但是从来没有一个联盟或者军团能依靠收税就可以覆盖战斗补损和堡垒建设。
但是我们伟大的NDRC确试图做到。具体的说，前几个月通过的从10%提高到15%税率议案试图实现这个壮举。 此议案就是 对这种头痛医头，脚痛医脚的目光狭隘的提税议案的狙击。
2. 考察以往15%提税议案的KPI 伟大的15%税率议案在NDRC通过了，让我们看看其意图和最终效果:
提税为了增加收入: 提税导致原有纳税大户，比如佐佐出走。之前可以贡献FPC 50%以上的玩家跑了。蛮子证实，税收反而低了，至少感觉不明显。 提税为了补贴pvp玩家: 然而4个月没发分红了，提税前反而有分红。 提税为了战斗补损失: 然而两月前的无畏战损至今还没补完。 总之，原有提税议案的愿景都没有实现，失败了。
3. NDRC联盟目前面临最大的问题 人口是最大问题，金鹏编制以及还在梦中的噩梦编制，缺人。 缺钱是第二位的。那些富豪在乎无畏的补损吗？（小声说一句，我还是在意的.) 利用这次CCP税改，推进NDRC低税，实现人口增长，是本议案最大的目标。 4. 为什么建议联盟5%统一税收 需要摆正对税收的观点: 从来没有战斗联盟靠税收发展壮大的，没有其他产业或者个人的补贴。联盟一定是入不敷出的。 税收不可能覆盖所有的战损，比如无畏战损，比如神装散打船。同时也做不到补贴pvp玩家。目前NDRC精英出去散打，克隆体都几十亿，不可能做到补损。 税收的目的: 税收是为联盟发展而服务的，能聚集更多的人一起玩。 低税的好处: 利于招新，6%全宇宙最低税率口号可以喊得很响亮。洗刷上次提税带来的谣言:NDRC 45%的税率。 低税可能提高税收总额，人多了，生产活动多了，基数大了后反而会提高税收。 %5税率不完全是低税: 以前的10%税率，其实相当于燃烧任务总收入的4%(大约). 假设军团6%税率，提高了近50%的额度。 统一税率的好处: 看起来低，便于招新喊口号。 计算简单。不会因为LP汇率而浮动。 兼顾了isk收入和LP调控手段。 5. 5%税细则 联盟对军团全部成员征收NPC赏金以及任务的ISK和LP收入的5%. 5%联盟统一税率，下月，即2023年7月1日实施。 建议军团 统一税率6%,自己留1%.(联盟宗旨不干涉军团内部事务，所以只是建议) LP变现的建议: 大概率出现isk不足的情况，LP变现建议采用拍卖的方式，价高者中标。 </description>
    </item>
    
  </channel>
</rss>

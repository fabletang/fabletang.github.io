[{"categories":["Shortcode"],"content":"本文展示了如果使用 alert shortcode。\n{{\u0026lt; alert \u0026#34;Message\u0026#34; [type] \u0026gt;}}  The parameter type is optional. Default to info.\n Info {{\u0026lt; alert \u0026#34;Info\u0026#34; \u0026gt;}} Info  Success {{\u0026lt; alert \u0026#34;Success\u0026#34; success \u0026gt;}} Success  Warning {{\u0026lt; alert \u0026#34;Warning\u0026#34; warning \u0026gt;}} Warning  Danger {{\u0026lt; alert \u0026#34;Danger\u0026#34; danger \u0026gt;}} Danger ","permalink":"https://fabletang.github.io/posts/shortcodes/alert/","series":["用户手册"],"tags":["Alert"],"title":"Alert Shortcode"},{"categories":["Shortcode"],"content":"关于哔哩哔哩 shortcode 的详细使用说明。\n使用 {{\u0026lt; bilibili \u0026#34;video id\u0026#34; \u0026gt;}} 例子  ","permalink":"https://fabletang.github.io/posts/shortcodes/bilibili/","series":null,"tags":["哔哩哔哩"],"title":"Bilibili Shortcode"},{"categories":["Shortcode"],"content":"关于 CodePen shortcode 的详细说明。\n使用 {{\u0026lt; codepen \u0026#34;id\u0026#34; \u0026gt;}} 例子  ","permalink":"https://fabletang.github.io/posts/shortcodes/codepen/","series":null,"tags":["CodePen"],"title":"CodePen Shortcode"},{"categories":["Shortcode"],"content":"关于 JSFiddle shortcode 的详细说明。\n使用 {{\u0026lt; jsfiddle \u0026#34;user/id\u0026#34; \u0026gt;}} 例子  ","permalink":"https://fabletang.github.io/posts/shortcodes/jsfiddle/","series":null,"tags":["JSFiddle"],"title":"JSFiddle Shortcode"},{"categories":["Shortcode"],"content":"关于 JSRun shortcode 的详细说明。\n使用 {{\u0026lt; jsrun \u0026#34;id\u0026#34; \u0026gt;}} 例子  ","permalink":"https://fabletang.github.io/posts/shortcodes/jsrun/","series":null,"tags":["JSRun"],"title":"JSRun Shortcode"},{"categories":["Shortcode"],"content":"关于优酷 shortcode 的详细说明。\n使用 {{\u0026lt; youku \u0026#34;XNTQwMTgxMTE2\u0026#34; \u0026gt;}} 例子  ","permalink":"https://fabletang.github.io/posts/shortcodes/youku/","series":null,"tags":["Youku"],"title":"优酷 Shortcode"},{"categories":["Shortcode"],"content":"关于爱奇艺 shortcode 的详细说明。\n使用 {{\u0026lt; iqiyi \u0026#34;vid\u0026#34; \u0026#34;tvid\u0026#34; \u0026gt;}} 例子  ","permalink":"https://fabletang.github.io/posts/shortcodes/iqiyi/","series":null,"tags":["爱奇艺"],"title":"爱奇艺 Shortcode"},{"categories":["Shortcode"],"content":"关于网易云音乐 Shortcode 的详细使用说明。\n使用 {{\u0026lt; neteasemusic \u0026#34;id\u0026#34; [auto [type]] \u0026gt;}}    Parameter Description     auto The auto controls whether to autoplay. Boolean and optional, default to false.   type The type parameter is optional. Default to 2.    例子  ","permalink":"https://fabletang.github.io/posts/shortcodes/neteasemusic/","series":null,"tags":["网易云音乐"],"title":"网易云音乐 Shortcode"},{"categories":["Shortcode"],"content":"关于腾讯视频 shortcode 的详细说明。\n使用 {{\u0026lt; tencentvideo \u0026#34;vid\u0026#34; \u0026gt;}} 例子  ","permalink":"https://fabletang.github.io/posts/shortcodes/tencentvideo/","series":null,"tags":["腾讯视频"],"title":"腾讯视频 Shortcode"},{"categories":null,"content":"一、docker rmi:  使用多个images id删除,前四位、空格区分  docker rmi 861b 7d51 过滤批量删除镜像, 对docker images 显示的行进行过滤。   根据tag名删除  docker rmi -f $(docker images | grep \u0026#34;fabletang/test-*\u0026#34; | awk \u0026#34;{print \\$3}\u0026#34;) docker rmi -f $(docker images | grep \u0026#34;\u0026lt;none\u0026gt;\u0026#34; | awk \u0026#34;{print \\$3}\u0026#34;)  根据版本号删除  docker rmi -f $(docker images | grep \u0026#34;0.0.1\u0026#34; | awk \u0026#34;{print \\$3}\u0026#34;)  根据Tag和版本号删除  docker rmi -f $(docker images | grep \u0026#34;fabletang/service-java\u0026#34; | awk -F\u0026#39; 0.\u0026#39; \u0026#39;{if ($2\u0026lt;0.6) print $0}\u0026#39; | awk \u0026#34;{print \\$3}\u0026#34;) ","permalink":"https://fabletang.github.io/posts/2017-09-16-docker_tips/","series":null,"tags":["docker"],"title":"docker tips"},{"categories":null,"content":"环境:centos7,docker 1.12+，registry 2.\n一、准备工作: mkdir /data/docker-registry mkdir /data/docker-registry-auth 二、安全设置: 生成 http 密码文件\ndocker run --entrypoint htpasswd registry:2 -Bbn anycloud \u0026#39;123\u0026#39;\u0026gt; /data/docker-registry-auth/htpasswd 获取 SSL 证书 git clone https://github.com/letsencrypt/letsencrypt cd letsencrypt ./letsencrypt-auto --help ./letsencrypt-auto certonly --standalone -d \u0026lt;HOST\u0026gt; 三、启动: 新增systemd守护服务,内容如下\ncat /etc/systemd/system/multi-user.target.wants/docker-registry.service [Unit] Description=registry Requires=docker.service After=docker.target [Service] Restart=always RestartSec=20 TimeoutStartSec=5min ExecStartPre=-/usr/bin/docker kill registry ExecStart=/usr/bin/docker run -p 5000:5000 --name registry \\ -v /data/docker-registry-auth/:/certs \\ -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/fullchain.pem \\ -e REGISTRY_HTTP_TLS_KEY=/certs/privkey.pem \\ -e REGISTRY_STORAGE_DELETE_ENABLED=true \\ -v /data/docker-registry-auth/:/auth \\ -e \u0026#34;REGISTRY_AUTH=htpasswd\u0026#34; \\ -e \u0026#34;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\u0026#34; \\ -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\ -e REGISTRY_STORAGE_DELETE_ENABLED=true \\ -v /data/docker-registry/:/var/lib/registry \\ registry:2 ExecStartPost=-/usr/bin/docker rm registry ExecStop=/usr/bin/docker stop registry ExecStopPost=-/usr/bin/docker rm registry [Install] WantedBy=multi-user.target 启动registry\nsystemctl daemon-reload systemctl start docker-registry 四、检验: 浏览器 https://localhost:5000/v2/ 密码登入,假如 显示 {} 之类的json文本,则说明成功。\n","permalink":"https://fabletang.github.io/posts/2017-09-01-docker_registry/","series":null,"tags":["docker"],"title":"docker私有仓库搭建"},{"categories":null,"content":"Go的设计思想是代码至上，依赖于代码而不是象其它语言依赖于编译好的库。尽管go的版本号已经到1.8.1了,但是还没没有好的package版本管理策略。1.6推出的vender只是稍微缓解了困境,只有寄希望与将来的1.9版本了。Go的代码结构不同于其它语言的地方,以java为对照:\n代码文件位于src目录 假如GOPATH对应项目goprojectstruct,代码文件应该处于 goprojectstruct/src目录内.\nGo无class的概念 Go无对象编程的类class的概念。所以代码文件名称可以随意定义，但是一般位于package目录,一般与package同名，但是拆分成几个文件也是可以的。\n代码文件/package名为小写 Java文件名一般为大写。Go以简单为宗旨，显然小写字母要简单,也符合go的定义，小写代表私有private，大写代表公开public。\n单元测试文件 单元测试文件与被测试文件处于同一目录，文件名追加\u0026quot;_test\u0026quot;,比如 hello.go的测试文件为 hello_test.go.\n引用库位于vender 所有外来引入的package都应该处于vender目录下。.gitignore也应该忽略vender目录。以此保持代码结构的精简。\npackage版本管理 在go1.9之前，推荐采用glide来管理。\n","permalink":"https://fabletang.github.io/posts/2017-05-01-the_struct_of_go_project/","series":null,"tags":["golang"],"title":"Golang代码结构"},{"categories":null,"content":"得益于nginx等反向代理的流行以及metrics/endpoit规范的成熟。微服务的理念开始流行了。 但是微服务究竟要多\u0026quot;微\u0026quot;才合适？以下是我的个人实践。\n不能按接口分: 这样的粒度太细.比如新增订单/查询订单分为两个microservice,优点是可以根据各自的负载合理分配服务器 资源。缺点是microservice数量过多，这样拆分的话，至少存在几十个service，这样对service的依赖关系，监控 ／部署都增加很大的难度。\n不能按数据库表名(table)分: 这是个鲁莽的做法。很明显，数据库的的事务处理将极为棘手。\n不能按数据库名(db)分: 这样的粒度太粗.好处是本地数据库数据一致性问题很好解决。缺点是功能过于集中，不利于后期改进。\n建议按子业务分，同时考虑数据库表的关联: 比如按订单/用户管理这样的粒度分，数据库表相对独立。这样service的数量较为合适，语意上也容易理解。\n","permalink":"https://fabletang.github.io/posts/2017-04-01-granularity_of_microservice/","series":null,"tags":["practice"],"title":"微服务的粒度"},{"categories":null,"content":"stateless server 即无状态服务。相对与传统的http server存在session,无session的 http server称为stateless server，现在一般应用于restful service.\nWhy: session的概念存在这么多年，一定有其合理之处,为什么要抛弃它?\n  session的起源: session根源于http的cookie. http协议本身是无状态的协议，server是一问一答，答后不管。为了加入 状态，来辨识是否访问／是否登录的需要，加入了cookie。服务器的session就是对应浏览器端的cookie.\n  为什么抛弃session:\n  高并发的访问，session制约了server的水平扩展。在负载均衡的多个server群，虽然可以用高速缓存比 如redis来管理全局session.但是毕竟多存在了一个节点，削弱了系统稳定性。\n  session需要资源开销，在tomcat中，每个session至少耗费4k内存。\n  session存在安全缺陷，一般session会以明文形式写入cookie,cookie是保存在浏览器端的硬盘，由此引发 的安全问题可以写成一本书了。即使禁用cookie, session也容易被窃取，CSRF跨域攻击就是窃取session的 安全问题。\n  随着server的功能增多，有时候需要跨域访问的时候，session成为了障碍。比如网页需要访问两个服务器的 资源，而且都必须要要登录授权保持状态,这样需要两个sessionid,但是浏览器只支持单一session.\n  What: stateless server是否就是服务器不需要state状态？ 需要授权的资源如果不保存其状态，比如用户id／角色。每次访问都要重新提交验证信息。服务器可能要重复 验证／查询数据库,这样会带来额外的资源开销。 所以，stateless应该理解为服务器不保存状态。\nHow: server需要状态，但是不保存状态。怎么做？ 采用jwt,状态保存在客户端。jwt 即json web token. server 把状态放入jwt,加密，以字符串的方式发送给客户端。\n采用jwt的好处:\n 可以封装状态，以key／value字符的形式保存状态。 安全。jwt一般采用对称或者非对称加密。加密密钥存放在server.可以防止jwt被篡改。jwt同时有时效性，合适的有效期可以减少重放攻击的可能性。  ","permalink":"https://fabletang.github.io/posts/2017-01-01-stateless_server/","series":null,"tags":["practice"],"title":"stateless server 最佳实践"},{"categories":null,"content":"\u0026ldquo;凡事预则立 不预则废\u0026rdquo;,这是\u0026laquo;礼记\u0026raquo;中的名言,意思是任何事情不作计划就会失败。\n软件项目也一样必须作计划。但是实际情况是，软件项目很难预估资源和时间。软件开发中\n有个“公理”：20%的工作要花费80%的时间。二八原理。还有一个\u0026quot;20%的项目是成功，80%\u0026quot;\n将失败\u0026quot;。说明软件项目很难作出贴近实际的计划(schedule)。Why?\n特性: 软件项目大多是创造性，难度大，复杂程度高。就单单编程语言来说，在电脑领域已发 明了上千不同的编程语言，而且每年仍有新的编程语言诞生。\n资源: 软件项目的主要资源:人,是稀缺的。需要较高技能要求。\n","permalink":"https://fabletang.github.io/posts/2015-10-06-project-schedule/","series":null,"tags":["project"],"title":"关于软件项目计划的看法"},{"categories":null,"content":"Grails是一套用于快速Web应用开发的开源框架，它基于Groovy编程语言，并构建于Spring、Hibernate等开源框架之上，是一个高生产力一站式框架。其官方网站上的煽情介绍为：The search is over!, 即为不要再苦苦寻找web开发框架了，Grails是终结者。\n如果web项目组大部分懂java，又没有旧的web项目负担。Grails是明智的选择。 缺点: groovy是类java的脚本解释动态语言，尽管其兼容java所有语法，最终也运行于JVM,但是速度有所影响.总体grails 比rails快，慢于传统ssh(struts/spring/hiberate)框架. 除了稍慢的运行速度，grails相对SSH全面胜出，以下是论点:\n一、学习成本低:  groovy语法不用学习，如果懂得java,groovy就是秒懂，实在不行，完全用java的语法也没有任何问题。其实注重运行速度的功能，比如加密解密，数据排序等算法推荐用java编写，groovy可以无缝引用。 grails的springframework\\hibernat极易使用，基本不用学习，完全不用理会那些迷宫式xml配置。grails会自动帮你处理好。  二、开发速度快:  grails 不是粗糙的ssh,它甚至有命令控制台，比如 grails create-control abc.login,就自动创建好了control及相关的测试文件。不用手动建立目录，建立文件。 调试便捷，run-app命令就可以运行一个web服务器，不需要启动额外的tomcat或者其他web容器, 同时它还是热编译的，也就是说，运行期间，你改动代码，grail自动就编译好了，不需要重新启动，哪怕你改动control都可以。 3.groovy语言大大减少了java的繁杂，同时集成很多通用库，可以大大减少代码.  三、功能完善: ssh是个粗糙的框架，不怀疑可以很快写出一个CURD的功能块。但是这远远不能应付实际项目需求，还得做大量的工作。\n  view层： grails 集成了sitmesh模版，而且自动加载缓存，模块化view。GSP相对structs的标签更好用。\n  control层: view数据绑定支持list,可以实现多维数据结构。spring mvc只支持map/bean 键值绑定方式。数据渲染很容易实现json/xml输出。比如 render xxxxbean as JSON\n  model层: 易于处理多对多，一对多，级联删除，完全不用去配置hibernat XML. 脏数据处理，数据缓存默认集成。\n  测试功能完备，易于使用，m/v/c各层都容易实现测试.\n  其他小功能完备，比如内置一个内存数据库，项目发布时候无缝切换实际数据库。\n  四、项目易于管理:  Grails 的原则是约定大于配置，也就是说配置文件，文件目录，命名方式都是约定好的。开放人员就是做填空题。项目自然就规范了。 Grails大大减少了配置文件，groovy语法大大缩减了代码量，越少的编码意味更好维护。 Grails开发模式下的热部署功能给前端开发提供很大便利，可以不重启web容器就可以即使得到改动的效果。这样利于前端后端开发分工。  ","permalink":"https://fabletang.github.io/posts/2014-12-25-grails_intro/","series":null,"tags":["java"],"title":"Grails框架介绍"},{"categories":null,"content":"鄙人喜欢狗，对养鱼这种雅趣向来不屑一顾。几个月前儿子笑盈盈地提着一个透明小水盒，\n得意的炫耀他钓的金鱼。原来是公园的付费小娱乐，每次十元，规定时间内钓的金鱼就可以\n带回。我瞅了瞅，6条小金鱼，不是锦鲤，也不是那种鱼鳍眼睛特别大的金鱼，就是鱼鳍比一般\n鲤鱼大一点，颜色更鲜艳的金色小鲤鱼, 不是什么名贵品种。似乎刚被勾上来，神情恹恹，浮在\n透明塑料小盒子里。看来没几天好活，不忍心打击儿子的童心，便答应养着。\n一个星期后，死了一条，剩下5条居然活了下来，使劲游水，已经适应了环境。就多留意了一些，\n晚上睡觉的时候，也偶尔听到小鱼吧嗒水泡的声音，似乎是小水盒太挤，氧气不足,所以游在水面\n上吐泡泡。\n又过了大半个月，5条金鱼没减员，而且更见活泼。每次投食都聚集过来吐泡泡，拼命摆动尾巴。\n好吧，毕竟是5条生命，既然安了家，就一起生活吧。催着家人去菜市场买个大点的鱼缸。\n几天后，金鱼就快活的游在一个椭圆形的玻璃缸里，后来听人说水草能改水质, 就买了几根鞭子\n一样的水草，但是没多久叶子就被啃光了。 每天早晚两次投食，应该没这么饿吧。跟人交流，对方\n也是惊诧, 我嘴里说着这鱼是个吃货，心里居然有小小的得意。\n后来那个小的椭圆形玻璃缸，因为每3天要换水，不小心磕坏了。\n现在是一个20cm20cm20cm的小鱼缸(家里太小),安装了一个2w的过滤器，水流冲下来带来小气泡，\n兼任加氧的功能。不打算用那种自动偷食，光照，加氧，调温，过滤的专业鱼箱。又讨来几个石螺，\n帮忙清理排泄物。这样就不用3天整个换水了，一周换几杯水就够了。\n每次靠近鱼箱，小家伙们就凑过来，拼命吐泡泡，摇尾巴。看来以后要一起生活了。 ^_^\n","permalink":"https://fabletang.github.io/posts/2014-10-19-goldfish/","series":null,"tags":["others"],"title":"养金鱼"},{"categories":null,"content":"gradle 现在已经2.1版本了。从1.0版本就一直关注这个groovy项目，但是没有应用到\n公司项目的打算，但是现在时机到了。gradle已经是最好的java自动构建工具，没有之一。\n一、gradle基于动态语言groovy groovy是java的动态版，闭包的特性让其编译脚本更加自由。\n比如你可以指定项目的某个目录用特定jdk版本编译。\n二、gradle 可以完全利用已有的maven库资源 maven库资源已经发展非常成熟，几乎没有找不到的开源库。\n三、gradle插件非常丰富，已经支持android项目构建。 没错，你现在可以用gradle一个命令实现android项目的编译，打包，上传，运行。\n插件: com.android.tools.build:gradle:0.13,已经可以胜任任何android项目构建，包括NDK.\nAndroid Studio 0.8.12 已经非常成熟，可以自动生成gradle.build配置文件。\n至于普通的java构建，就没有gradle不能做的。\n四、gradle学习成本低 gradle学习成本很低，比ant低，比maven低。但是更加强大。\n","permalink":"https://fabletang.github.io/posts/2014-10-13-introduce-gradle/","series":null,"tags":["toolbox"],"title":"Gradle 介绍"},{"categories":null,"content":"由于长期在linux下做开发，严重依赖linux的各种小方便，然而需要参与一个Android项目。 项目里有公司开发的.so，涉及了JNI。开始我使用的是eclipse ADT, linux 的usb联机调试也 搞定了，一切似乎都很顺利，usb联机上传也成功了，app出来了，点击，然后就崩溃了，logcat 提示找不到 XXX.so。本来就对eclipse这个老破车有成见，利用这个借口，开始用android studio\n环境说明:\nUbuntu /Windows, android studio 0.8.6+\n以下是要点：\n一、studio 可以直接从eclipse导入,gradle build成功，但是出现编码错误（\\78XXX) 这个是编码错误，用笨办法，右键出错文件，enconding GBK, 然后再 UTF-8.\n二、编译通过，但是联机调试出现上传错误，提示XX.jar重复copy. 这个是studio本身bug, 在 app下的build.gradle 的 android {\u0026hellip;}内加入\npackagingOptions { exclude \u0026#39;META-INF/DEPENDENCIES.txt\u0026#39; exclude \u0026#39;META-INF/LICENSE.txt\u0026#39; exclude \u0026#39;META-INF/NOTICE.txt\u0026#39; exclude \u0026#39;META-INF/NOTICE\u0026#39; exclude \u0026#39;META-INF/LICENSE\u0026#39; exclude \u0026#39;META-INF/DEPENDENCIES\u0026#39; exclude \u0026#39;META-INF/notice.txt\u0026#39; exclude \u0026#39;META-INF/license.txt\u0026#39; exclude \u0026#39;META-INF/dependencies.txt\u0026#39; exclude \u0026#39;META-INF/LGPL2.1\u0026#39; } 三、local.properties 是定义 sdk.dir 和 ndk.dir.需要根据本机andoird jdk情况调整。 四、JNI 相关的问题:   android studio 的ndk 不完善，没有eclipse支持那么好。但是也是可以用的，需要在build.gradle\n里配置，具体请参看gradle官方文档.\n  JNI生成的.so打包apk。.so位于 libs/armeabi 目录,在 app下的build.gradle 的 android {\u0026hellip;}内加入\n  sourceSets { main { jniLibs.srcDirs = [\u0026#39;libs\u0026#39;] } } ","permalink":"https://fabletang.github.io/posts/2014-09-30-android-studio-conf/","series":null,"tags":["android","toolbox"],"title":"Android Studio 配置"},{"categories":null,"content":"环境说明: Ubuntu 14.04, android ADT 4.2.2\nLinux 下 ADT usb联机调试出现 device unknown 的解决办法:\n一、使用lsusb命令查看设备的vendorId和productId。 插入usb线前后用lsusb查看，找出多出的信息。\n$ lsusb Bus 003 Device 005: ID 0bb4:0c03 HTC (High Tech Computer Corp.) 二、在/etc/udev/rules.d/目录下面新建一个规则文件 51-android.rules 添加一行 SUBSYSTEM==\u0026#34;usb\u0026#34;,ATTRS {idVendor}==\u0026#34;0bb4\u0026#34;,ATTRS {idProduct}==\u0026#34;0c03\u0026#34;,MODE=\u0026#34;0666\u0026#34; 0666 表示对所有用户，开放adb所有权限\n三、 重启usb服务，命令如下： sudo service udev restart 四、 重置ADB  拔下USB与PC连接线，然后再次插上，进入Android-SDK根目录Platform-tools，运行命令:\n$which adb $sudo ./adb kill-server $sudo ./adb devices 五、 把adb命令加入环境变量 查找adb所在路径\n$which adb 编辑~/.bashrc文件,增加\nexport PATH=.:$PATH:adb路径 这样就不用每次进入adb目录了。\n","permalink":"https://fabletang.github.io/posts/2014-09-29-android-usb-ubunit/","series":null,"tags":["android","toolbox"],"title":"Ubuntu下Android USB联机调试"},{"categories":null,"content":"网上很多svn server的配置文章，要么是windows下的visualSVN,要么配置错误。 以下是关键点:\n一、确保仓库目录权限正确: $ sudo adduser svnuser 添加SVN账号 $ sudo addgroup subversion 添加SVN组 $sudo usermod -G subversion -a svnuser 将svnuser添加到subversion组 $sudo chown -R svnuser:subversion 仓库目录 二、修改任何svn的文件必须切换svnuser用户: $ sudo su svnuser 三、svn实质是对目录的权限控制。 ","permalink":"https://fabletang.github.io/posts/shortcodes/2014-09-23-svn_server/","series":null,"tags":["linux","toolbox"],"title":"linux svn server 搭建"}]
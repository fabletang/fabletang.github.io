[{"categories":["技术"],"content":"java单例模式有5种实现方式,推荐以下3种方式. 一、单例-饿汉式: 特点:线程安全，不能延时加载\npublic enum SingletonDemo1 { //枚举元素本身就是单例  INSTANCE; //添加自己需要的操作  public void singletonOperation(){ } } 二、单例-懒汉式-双重锁检查: 特点:线程安全，延时加载。 ps: java1.5后,volatile可以避免jvm初始化内存分配可能乱序的问题。\npublic class SingletonDemo2 { private static volatile SingletonDemo2 SingletonDemo2; private SingletonDemo2() { } public static SingletonDemo2 newInstance() { if (SingletonDemo2 == null) { synchronized (SingletonDemo2.class) { if (SingletonDemo2 == null) { SingletonDemo2 = new SingletonDemo2(); } } } return SingletonDemo2; } } 三、单例-懒汉式-静态内部类: 特点:线程安全，延时加载。\npublic class SingletonDemo3 { private static class SingletonClassInstance{ private static final SingletonDemo3 instance=new SingletonDemo3(); } private SingletonDemo3(){} public static SingletonDemo3 getInstance(){ return SingletonClassInstance.instance; } } 四、多例: 多例模式，我们可以将类的实例都编上号，然后将实例存放在一个Map:\npublic class MultiInstance { // 实例编号  private long instanceNum; // 用于存放实例  private static final Map\u0026lt;Long, MultiInstance\u0026gt; ins = new HashMap\u0026lt;\u0026gt;(); static { // 存放 3 个实例  ins.put(1L, new MultiInstance(1)); ins.put(2L, new MultiInstance(2)); ins.put(3L, new MultiInstance(3)); } private MultiInstance(long n) { this.instanceNum = n; } public MultiInstance getInstance(long n) { return ins.get(n); } } 实际上,Java 中的枚举就是一个“天然”的多例模式,其中的每一项代表一个实例:\npublic enum MultiInstance { ONE, TWO, THREE; } 五、线程中的单例: 一般情况下，我们所说的单例的作用范围是进程唯一的，就是在一个进程范围内，一个类只允许创建一个对象，进程内的多个线程之间也是共享同一个实例。 那么线程唯一的单例就是，一个实例只能被一个线程拥有，一个进程内的多个线程拥有不同的类实例。 我们同样可以用 ConcurrentHashMap 来实现:\npublic class ThreadSingleton { private static final ConcurrentHashMap\u0026lt;Long, ThreadSingleton\u0026gt; instances = new ConcurrentHashMap\u0026lt;\u0026gt;(); private ThreadSingleton() {} public static ThreadSingleton getInstance() { Long id = Thread.currentThread().getId(); instances.putIfAbsent(id, new ThreadSingleton()); return instances.get(id); } } ","permalink":"https://fabletang.github.io/posts/2021-02-26-java_singleten_pattern/","series":["编程"],"tags":["java"],"title":"java模式:单例/多例/线程单例"},{"categories":["管理"],"content":" 很多技术人不喜欢管理，就像古代书生怕碰到铜钱，沾染了“铜臭”变得不纯洁了。 管理，第一是对自我的管理,自己的工作方式。不要把管理想象成奴役他人的皮鞭，可以认为管理首先是规范自己的 戒尺，然后把这根戒尺变成指挥棒去协调团队。 某些同学看了这些书，甚至考试认证都过了，还是没找到管理的感觉。 今天跟大家探讨一下，怎么学习管理理论。  一、学习的广度  站在巨人肩膀上做事是理所当然的，所以管理相关的理论知识要先学习。这方面的权威书籍有很多， 比如国家软件项目管理考试、国际pmp项目管理认证,都是很好的教材，这些教材每年都有更新，比如scrum都包含在内。 网络上有最新的管理方法，比如OKR.这些也需要了解,现在信息交流快捷，几年就会变换一种主流管理方法。  二、学习的深度  理工科毕业的技术人讲究“实证\u0026quot;,对书本上泛泛而论的管理方法很难产生共鸣，自己都不信的理论，当然就很难在 实际工作中运用。 但是我们可以采用数理的逻辑来印证管理理论: 比如“过程管理\u0026quot;,很多管理方法都提到这个词，为什么一定要“过程管理“解释得并不通透， 如果联系到理工科都学过的“工业自动化”的“闭环反馈\u0026quot;就容易明白了。 又比如“扁平式组织结构”，如果联系到 “信息论\u0026quot;里的“任何信息传递、转换都会有损耗”, 就很容易理解层级少的组织可以减少沟通成本。  三、以人为本  管理是对人的规则。 人是不一样的，同样的人在不同时期也是不一样的。所以大家可以观察到主流管理方法会随时间 而淘汰，不同行业的主流管理方法也不一样。体察人性，与对应的管理方法对应起来，深刻领会原因, 这样就会\u0026quot;相信\u0026quot;, 只有你“信”，才能影响他人。  ","permalink":"https://fabletang.github.io/posts/2021-02-17-methodology_1/","series":["心得"],"tags":["project"],"title":"技术管理-怎么学"},{"categories":["技术"],"content":"一、docker rmi:  使用多个images id删除,前四位、空格区分  docker rmi 861b 7d51 过滤批量删除镜像, 对docker images 显示的行进行过滤。   根据tag名删除  docker rmi -f $(docker images | grep \u0026#34;fabletang/test-*\u0026#34; | awk \u0026#34;{print \\$3}\u0026#34;) docker rmi -f $(docker images | grep \u0026#34;\u0026lt;none\u0026gt;\u0026#34; | awk \u0026#34;{print \\$3}\u0026#34;)  根据版本号删除  docker rmi -f $(docker images | grep \u0026#34;0.0.1\u0026#34; | awk \u0026#34;{print \\$3}\u0026#34;)  根据Tag和版本号删除  docker rmi -f $(docker images | grep \u0026#34;fabletang/service-java\u0026#34; | awk -F\u0026#39; 0.\u0026#39; \u0026#39;{if ($2\u0026lt;0.6) print $0}\u0026#39; | awk \u0026#34;{print \\$3}\u0026#34;)  删除所有未运行 Docker 容器  docker rm $(docker ps -a -q) ","permalink":"https://fabletang.github.io/posts/2017-09-16-docker_tips/","series":["工具"],"tags":["docker","tips"],"title":"docker tips"},{"categories":["技术"],"content":"环境:centos7,docker 1.12+，registry 2.\n一、准备工作: mkdir /data/docker-registry mkdir /data/docker-registry-auth 二、安全设置: 生成 http 密码文件\ndocker run --entrypoint htpasswd registry:2 -Bbn anycloud \u0026#39;123\u0026#39;\u0026gt; /data/docker-registry-auth/htpasswd 获取 SSL 证书 git clone https://github.com/letsencrypt/letsencrypt cd letsencrypt ./letsencrypt-auto --help ./letsencrypt-auto certonly --standalone -d \u0026lt;HOST\u0026gt; 三、启动: 新增systemd守护服务,内容如下\ncat /etc/systemd/system/multi-user.target.wants/docker-registry.service [Unit] Description=registry Requires=docker.service After=docker.target [Service] Restart=always RestartSec=20 TimeoutStartSec=5min ExecStartPre=-/usr/bin/docker kill registry ExecStart=/usr/bin/docker run -p 5000:5000 --name registry \\ -v /data/docker-registry-auth/:/certs \\ -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/fullchain.pem \\ -e REGISTRY_HTTP_TLS_KEY=/certs/privkey.pem \\ -e REGISTRY_STORAGE_DELETE_ENABLED=true \\ -v /data/docker-registry-auth/:/auth \\ -e \u0026#34;REGISTRY_AUTH=htpasswd\u0026#34; \\ -e \u0026#34;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\u0026#34; \\ -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\ -e REGISTRY_STORAGE_DELETE_ENABLED=true \\ -v /data/docker-registry/:/var/lib/registry \\ registry:2 ExecStartPost=-/usr/bin/docker rm registry ExecStop=/usr/bin/docker stop registry ExecStopPost=-/usr/bin/docker rm registry [Install] WantedBy=multi-user.target 启动registry\nsystemctl daemon-reload systemctl start docker-registry 四、检验: 浏览器 https://localhost:5000/v2/ 密码登入,假如 显示 {} 之类的json文本,则说明成功。\n","permalink":"https://fabletang.github.io/posts/2017-09-01-docker_registry/","series":["工具"],"tags":["docker"],"title":"docker私有仓库搭建"},{"categories":["技术"],"content":"Go的设计思想是代码至上，依赖于代码而不是象其它语言依赖于编译好的库。尽管go的版本号已经到1.8.1了,但是还没没有好的package版本管理策略。1.6推出的vender只是稍微缓解了困境,只有寄希望与将来的1.9版本了。Go的代码结构不同于其它语言的地方,以java为对照:\n代码文件位于src目录 假如GOPATH对应项目goprojectstruct,代码文件应该处于 goprojectstruct/src目录内.\nGo无class的概念 Go无对象编程的类class的概念。所以代码文件名称可以随意定义，但是一般位于package目录,一般与package同名，但是拆分成几个文件也是可以的。\n代码文件/package名为小写 Java文件名一般为大写。Go以简单为宗旨，显然小写字母要简单,也符合go的定义，小写代表私有private，大写代表公开public。\n单元测试文件 单元测试文件与被测试文件处于同一目录，文件名追加\u0026quot;_test\u0026quot;,比如 hello.go的测试文件为 hello_test.go.\n引用库位于vender 所有外来引入的package都应该处于vender目录下。.gitignore也应该忽略vender目录。以此保持代码结构的精简。\npackage版本管理 在go1.9之前，推荐采用glide来管理。\n","permalink":"https://fabletang.github.io/posts/2017-05-01-the_struct_of_go_project/","series":["编程"],"tags":["golang"],"title":"Golang代码结构"},{"categories":["技术"],"content":"得益于nginx等反向代理的流行以及metrics/endpoit规范的成熟。微服务的理念开始流行了。 但是微服务究竟要多\u0026quot;微\u0026quot;才合适？以下是我的个人实践。\n不能按接口分: 这样的粒度太细.比如新增订单/查询订单分为两个microservice,优点是可以根据各自的负载合理分配服务器 资源。缺点是microservice数量过多，这样拆分的话，至少存在几十个service，这样对service的依赖关系，监控 ／部署都增加很大的难度。\n不能按数据库表名(table)分: 这是个鲁莽的做法。很明显，数据库的的事务处理将极为棘手。\n不能按数据库名(db)分: 这样的粒度太粗.好处是本地数据库数据一致性问题很好解决。缺点是功能过于集中，不利于后期改进。\n建议按子业务分，同时考虑数据库表的关联: 比如按订单/用户管理这样的粒度分，数据库表相对独立。这样service的数量较为合适，语意上也容易理解。\n","permalink":"https://fabletang.github.io/posts/2017-04-01-granularity_of_microservice/","series":["概念"],"tags":["practice"],"title":"微服务的粒度"},{"categories":["技术"],"content":"stateless server 即无状态服务。相对与传统的http server存在session,无session的 http server称为stateless server，现在一般应用于restful service.\nWhy: session的概念存在这么多年，一定有其合理之处,为什么要抛弃它?\n  session的起源: session根源于http的cookie. http协议本身是无状态的协议，server是一问一答，答后不管。为了加入 状态，来辨识是否访问／是否登录的需要，加入了cookie。服务器的session就是对应浏览器端的cookie.\n  为什么抛弃session:\n  高并发的访问，session制约了server的水平扩展。在负载均衡的多个server群，虽然可以用高速缓存比 如redis来管理全局session.但是毕竟多存在了一个节点，削弱了系统稳定性。\n  session需要资源开销，在tomcat中，每个session至少耗费4k内存。\n  session存在安全缺陷，一般session会以明文形式写入cookie,cookie是保存在浏览器端的硬盘，由此引发 的安全问题可以写成一本书了。即使禁用cookie, session也容易被窃取，CSRF跨域攻击就是窃取session的 安全问题。\n  随着server的功能增多，有时候需要跨域访问的时候，session成为了障碍。比如网页需要访问两个服务器的 资源，而且都必须要要登录授权保持状态,这样需要两个sessionid,但是浏览器只支持单一session.\n  What: stateless server是否就是服务器不需要state状态？ 需要授权的资源如果不保存其状态，比如用户id／角色。每次访问都要重新提交验证信息。服务器可能要重复 验证／查询数据库,这样会带来额外的资源开销。 所以，stateless应该理解为服务器不保存状态。\nHow: server需要状态，但是不保存状态。怎么做？ 采用jwt,状态保存在客户端。jwt 即json web token. server 把状态放入jwt,加密，以字符串的方式发送给客户端。\n采用jwt的好处:\n 可以封装状态，以key／value字符的形式保存状态。 安全。jwt一般采用对称或者非对称加密。加密密钥存放在server.可以防止jwt被篡改。jwt同时有时效性，合适的有效期可以减少重放攻击的可能性。  ","permalink":"https://fabletang.github.io/posts/2017-01-01-stateless_server/","series":["概念"],"tags":["practice"],"title":"stateless server 最佳实践"},{"categories":["管理"],"content":"\u0026ldquo;凡事预则立 不预则废\u0026rdquo;,这是\u0026laquo;礼记\u0026raquo;中的名言,意思是任何事情不作计划就会失败。\n软件项目也一样必须作计划。但是实际情况是，软件项目很难预估资源和时间。软件开发中\n有个“公理”：20%的工作要花费80%的时间。二八原理。还有一个\u0026quot;20%的项目是成功，80%\u0026quot;\n将失败\u0026quot;。说明软件项目很难作出贴近实际的计划(schedule)。Why?\n特性: 软件项目大多是创造性，难度大，复杂程度高。就单单编程语言来说，在电脑领域已发 明了上千不同的编程语言，而且每年仍有新的编程语言诞生。\n资源: 软件项目的主要资源:人,是稀缺的。需要较高技能要求。\n","permalink":"https://fabletang.github.io/posts/2015-10-06-project-schedule/","series":["心得"],"tags":["project"],"title":"关于软件项目计划的看法"},{"categories":["技术"],"content":"Grails是一套用于快速Web应用开发的开源框架，它基于Groovy编程语言，并构建于Spring、Hibernate等开源框架之上，是一个高生产力一站式框架。其官方网站上的煽情介绍为：The search is over!, 即为不要再苦苦寻找web开发框架了，Grails是终结者。\n如果web项目组大部分懂java，又没有旧的web项目负担。Grails是明智的选择。 缺点: groovy是类java的脚本解释动态语言，尽管其兼容java所有语法，最终也运行于JVM,但是速度有所影响.总体grails 比rails快，慢于传统ssh(struts/spring/hiberate)框架. 除了稍慢的运行速度，grails相对SSH全面胜出，以下是论点:\n一、学习成本低:  groovy语法不用学习，如果懂得java,groovy就是秒懂，实在不行，完全用java的语法也没有任何问题。其实注重运行速度的功能，比如加密解密，数据排序等算法推荐用java编写，groovy可以无缝引用。 grails的springframework\\hibernat极易使用，基本不用学习，完全不用理会那些迷宫式xml配置。grails会自动帮你处理好。  二、开发速度快:  grails 不是粗糙的ssh,它甚至有命令控制台，比如 grails create-control abc.login,就自动创建好了control及相关的测试文件。不用手动建立目录，建立文件。 调试便捷，run-app命令就可以运行一个web服务器，不需要启动额外的tomcat或者其他web容器, 同时它还是热编译的，也就是说，运行期间，你改动代码，grail自动就编译好了，不需要重新启动，哪怕你改动control都可以。 3.groovy语言大大减少了java的繁杂，同时集成很多通用库，可以大大减少代码.  三、功能完善: ssh是个粗糙的框架，不怀疑可以很快写出一个CURD的功能块。但是这远远不能应付实际项目需求，还得做大量的工作。\n  view层： grails 集成了sitmesh模版，而且自动加载缓存，模块化view。GSP相对structs的标签更好用。\n  control层: view数据绑定支持list,可以实现多维数据结构。spring mvc只支持map/bean 键值绑定方式。数据渲染很容易实现json/xml输出。比如 render xxxxbean as JSON\n  model层: 易于处理多对多，一对多，级联删除，完全不用去配置hibernat XML. 脏数据处理，数据缓存默认集成。\n  测试功能完备，易于使用，m/v/c各层都容易实现测试.\n  其他小功能完备，比如内置一个内存数据库，项目发布时候无缝切换实际数据库。\n  四、项目易于管理:  Grails 的原则是约定大于配置，也就是说配置文件，文件目录，命名方式都是约定好的。开放人员就是做填空题。项目自然就规范了。 Grails大大减少了配置文件，groovy语法大大缩减了代码量，越少的编码意味更好维护。 Grails开发模式下的热部署功能给前端开发提供很大便利，可以不重启web容器就可以即使得到改动的效果。这样利于前端后端开发分工。  ","permalink":"https://fabletang.github.io/posts/2014-12-25-grails_intro/","series":["框架"],"tags":["java"],"title":"Grails框架介绍"},{"categories":null,"content":"鄙人喜欢狗，对养鱼这种雅趣向来不屑一顾。几个月前儿子笑盈盈地提着一个透明小水盒，\n得意的炫耀他钓的金鱼。原来是公园的付费小娱乐，每次十元，规定时间内钓的金鱼就可以\n带回。我瞅了瞅，6条小金鱼，不是锦鲤，也不是那种鱼鳍眼睛特别大的金鱼，就是鱼鳍比一般\n鲤鱼大一点，颜色更鲜艳的金色小鲤鱼, 不是什么名贵品种。似乎刚被勾上来，神情恹恹，浮在\n透明塑料小盒子里。看来没几天好活，不忍心打击儿子的童心，便答应养着。\n一个星期后，死了一条，剩下5条居然活了下来，使劲游水，已经适应了环境。就多留意了一些，\n晚上睡觉的时候，也偶尔听到小鱼吧嗒水泡的声音，似乎是小水盒太挤，氧气不足,所以游在水面\n上吐泡泡。\n又过了大半个月，5条金鱼没减员，而且更见活泼。每次投食都聚集过来吐泡泡，拼命摆动尾巴。\n好吧，毕竟是5条生命，既然安了家，就一起生活吧。催着家人去菜市场买个大点的鱼缸。\n几天后，金鱼就快活的游在一个椭圆形的玻璃缸里，后来听人说水草能改水质, 就买了几根鞭子\n一样的水草，但是没多久叶子就被啃光了。 每天早晚两次投食，应该没这么饿吧。跟人交流，对方\n也是惊诧, 我嘴里说着这鱼是个吃货，心里居然有小小的得意。\n后来那个小的椭圆形玻璃缸，因为每3天要换水，不小心磕坏了。\n现在是一个20cm20cm20cm的小鱼缸(家里太小),安装了一个2w的过滤器，水流冲下来带来小气泡，\n兼任加氧的功能。不打算用那种自动偷食，光照，加氧，调温，过滤的专业鱼箱。又讨来几个石螺，\n帮忙清理排泄物。这样就不用3天整个换水了，一周换几杯水就够了。\n每次靠近鱼箱，小家伙们就凑过来，拼命吐泡泡，摇尾巴。看来以后要一起生活了。 ^_^\n","permalink":"https://fabletang.github.io/posts/2014-10-19-goldfish/","series":null,"tags":["others"],"title":"养金鱼"},{"categories":["技术"],"content":"gradle 现在已经2.1版本了。从1.0版本就一直关注这个groovy项目，但是没有应用到\n公司项目的打算，但是现在时机到了。gradle已经是最好的java自动构建工具，没有之一。\n一、gradle基于动态语言groovy groovy是java的动态版，闭包的特性让其编译脚本更加自由。\n比如你可以指定项目的某个目录用特定jdk版本编译。\n二、gradle 可以完全利用已有的maven库资源 maven库资源已经发展非常成熟，几乎没有找不到的开源库。\n三、gradle插件非常丰富，已经支持android项目构建。 没错，你现在可以用gradle一个命令实现android项目的编译，打包，上传，运行。\n插件: com.android.tools.build:gradle:0.13,已经可以胜任任何android项目构建，包括NDK.\nAndroid Studio 0.8.12 已经非常成熟，可以自动生成gradle.build配置文件。\n至于普通的java构建，就没有gradle不能做的。\n四、gradle学习成本低 gradle学习成本很低，比ant低，比maven低。但是更加强大。\n","permalink":"https://fabletang.github.io/posts/2014-10-13-introduce-gradle/","series":["工具"],"tags":["toolbox"],"title":"Gradle 介绍"},{"categories":["技术"],"content":"由于长期在linux下做开发，严重依赖linux的各种小方便，然而需要参与一个Android项目。 项目里有公司开发的.so，涉及了JNI。开始我使用的是eclipse ADT, linux 的usb联机调试也 搞定了，一切似乎都很顺利，usb联机上传也成功了，app出来了，点击，然后就崩溃了，logcat 提示找不到 XXX.so。本来就对eclipse这个老破车有成见，利用这个借口，开始用android studio\n环境说明:\nUbuntu /Windows, android studio 0.8.6+\n以下是要点：\n一、studio 可以直接从eclipse导入,gradle build成功，但是出现编码错误（\\78XXX) 这个是编码错误，用笨办法，右键出错文件，enconding GBK, 然后再 UTF-8.\n二、编译通过，但是联机调试出现上传错误，提示XX.jar重复copy. 这个是studio本身bug, 在 app下的build.gradle 的 android {\u0026hellip;}内加入\npackagingOptions { exclude \u0026#39;META-INF/DEPENDENCIES.txt\u0026#39; exclude \u0026#39;META-INF/LICENSE.txt\u0026#39; exclude \u0026#39;META-INF/NOTICE.txt\u0026#39; exclude \u0026#39;META-INF/NOTICE\u0026#39; exclude \u0026#39;META-INF/LICENSE\u0026#39; exclude \u0026#39;META-INF/DEPENDENCIES\u0026#39; exclude \u0026#39;META-INF/notice.txt\u0026#39; exclude \u0026#39;META-INF/license.txt\u0026#39; exclude \u0026#39;META-INF/dependencies.txt\u0026#39; exclude \u0026#39;META-INF/LGPL2.1\u0026#39; } 三、local.properties 是定义 sdk.dir 和 ndk.dir.需要根据本机andoird jdk情况调整。 四、JNI 相关的问题:   android studio 的ndk 不完善，没有eclipse支持那么好。但是也是可以用的，需要在build.gradle\n里配置，具体请参看gradle官方文档.\n  JNI生成的.so打包apk。.so位于 libs/armeabi 目录,在 app下的build.gradle 的 android {\u0026hellip;}内加入\n  sourceSets { main { jniLibs.srcDirs = [\u0026#39;libs\u0026#39;] } } ","permalink":"https://fabletang.github.io/posts/2014-09-30-android-studio-conf/","series":["工具"],"tags":["android","tips"],"title":"Android Studio 配置"},{"categories":["技术"],"content":"环境说明: Ubuntu 14.04, android ADT 4.2.2\nLinux 下 ADT usb联机调试出现 device unknown 的解决办法:\n一、使用lsusb命令查看设备的vendorId和productId。 插入usb线前后用lsusb查看，找出多出的信息。\n$ lsusb Bus 003 Device 005: ID 0bb4:0c03 HTC (High Tech Computer Corp.) 二、在/etc/udev/rules.d/目录下面新建一个规则文件 51-android.rules 添加一行 SUBSYSTEM==\u0026#34;usb\u0026#34;,ATTRS {idVendor}==\u0026#34;0bb4\u0026#34;,ATTRS {idProduct}==\u0026#34;0c03\u0026#34;,MODE=\u0026#34;0666\u0026#34; 0666 表示对所有用户，开放adb所有权限\n三、 重启usb服务，命令如下： sudo service udev restart 四、 重置ADB  拔下USB与PC连接线，然后再次插上，进入Android-SDK根目录Platform-tools，运行命令:\n$which adb $sudo ./adb kill-server $sudo ./adb devices 五、 把adb命令加入环境变量 查找adb所在路径\n$which adb 编辑~/.bashrc文件,增加\nexport PATH=.:$PATH:adb路径 这样就不用每次进入adb目录了。\n","permalink":"https://fabletang.github.io/posts/2014-09-29-android-usb-ubunit/","series":["工具"],"tags":["android","tips"],"title":"Ubuntu下Android USB联机调试"}]
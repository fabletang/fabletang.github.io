[{"categories":["技术"],"content":"一、vim 文件管理相关 插件: \u0026#34; 文件管理插件  Plug \u0026#39;preservim/nerdtree\u0026#39;  Plug \u0026#39;Xuyuanp/nerdtree-git-plugin\u0026#39;\u0026#34; 历史文件增强 :browse oldfiles Plug \u0026#39;gpanders/vim-oldfiles\u0026#39;配置: \u0026#34; NERDTree插件的快捷键nn \u0026lt;silent\u0026gt; \u0026lt;F5\u0026gt; :NERDTreeToggle\u0026lt;CR\u0026gt;\u0026#34;自动启动nerdtreeautocmd VimEnter * NERDTree | wincmd p\u0026#34;:browse oldfiles 插件增强nmap \u0026lt;leader\u0026gt;b \u0026lt;Plug\u0026gt;(Oldfiles)\u0026#34; F2 通过打开的文件对齐树形目录nn \u0026lt;silent\u0026gt;\u0026lt;F2\u0026gt; :exec(\u0026#34;NERDTree \u0026#34;.expand(\u0026#39;%:h\u0026#39;))\u0026lt;CR\u0026gt;\u0026#34; Check if NERDTree is open or active,打开的文件自动定位目录function! IsNERDTreeOpen() return exists(\u0026#34;t:NERDTreeBufName\u0026#34;) \u0026amp;\u0026amp; (bufwinnr(t:NERDTreeBufName) != -1)endfunction\u0026#34; Call NERDTreeFind iff NERDTree is active, current window contains a modifiable\u0026#34; file, and we\u0026#39;re not in vimdifffunction! SyncTree() if \u0026amp;modifiable \u0026amp;\u0026amp; IsNERDTreeOpen() \u0026amp;\u0026amp; strlen(expand(\u0026#39;%\u0026#39;)) \u0026gt; 0 \u0026amp;\u0026amp; !\u0026amp;diff NERDTreeFind wincmd p endifendfunction\u0026#34; Highlight currently open buffer in NERDTreeautocmd BufEnter * call SyncTree() function! ToggleNerdTree() set eventignore=BufEnter NERDTreeToggle set eventignore=endfunction\u0026#34; shortcuts to make it easier to jump between errors in quickfix list:map \u0026lt;C-n\u0026gt; :cnext\u0026lt;CR\u0026gt;map \u0026lt;C-m\u0026gt; :cprevious\u0026lt;CR\u0026gt;nnoremap \u0026lt;leader\u0026gt;o :copen\u0026lt;CR\u0026gt;nnoremap \u0026lt;leader\u0026gt;oo :cclose\u0026lt;CR\u0026gt;\u0026#34; like \u0026lt;leader\u0026gt;w saves the current filelet mapleader = \u0026#34;,\u0026#34;let g:mapleader = \u0026#34;,\u0026#34;二、常用vim 文件操作 1.vim自带功能  打开文件: shell命令 \u0026ldquo;vim 路径/文件名\u0026rdquo; 或者在vim中\u0026quot;:e 路径/文件名\u0026quot; 写入文件: vim命令行 \u0026ldquo;:w 文件名\u0026rdquo;(无文件名则写入当前文件) 或者 \u0026ldquo;w\u0026rdquo;. 上面配置文件定义了\u0026quot;,\u0026ldquo;为. 打开历史文件列表: \u0026ldquo;:browse oldfiles\u0026rdquo;,这个功能不好用，要翻页到最后输入要打开的文件数字。 打开buffer文件列表: \u0026ldquo;:ls\u0026rdquo;  2.插件功能 vim-oldfiles  历史文件增强插件,用来快速浏览曾经打开过的文件\n 打开历史文件列表: \u0026ldquo;b\u0026quot;在quickfix窗口打开列表。 选择文件:上下选择。 关闭quickfix窗口: \u0026ldquo;oo\u0026rdquo;  nerdtree  流行的文件管理插件,配置自动启动以及自动匹配打开文件所在目录。\n 光标移动: j/k 找到当前目录: p 目录切换: 切换到上级目录: u,进入当前目录 回车 刷新当前目录: r  ","date":"2021-11-30","img":"","permalink":"https://fabletang.github.io/posts/2021-11-30-vim_file/","series":["工具"],"tags":["vim"],"title":"vim 文件相关操作(四)"},{"categories":["技术"],"content":"一、vim 窗口类别 1.文本窗口:  主窗口，文本区。\n2.buffer窗口:  vim运行期间的缓冲文件列表。关闭后清零。 打开: \u0026ldquo;:ls\u0026rdquo; 关闭: \u0026lt;ESC\u0026gt;或者选择一个文件序号自动关闭  3. quickfix窗口:  运行结果显示等。也有插件利用这个窗口显示文件列表。 打开: \u0026ldquo;\u0026lt;leader\u0026gt;o\u0026rdquo;,此快捷键参照配置文件定义。 \u0026lt;leader\u0026gt;为\u0026quot;,\u0026quot; 关闭: 按提示\u0026lt;CR\u0026gt;回车，或者 \u0026ldquo;\u0026lt;leader\u0026gt;oo\u0026rdquo;. 参照配置文件。   \u0026lt;leader\u0026gt;配置:\n\u0026#34; like \u0026lt;leader\u0026gt;w saves the current filelet mapleader = \u0026#34;,\u0026#34;let g:mapleader = \u0026#34;,\u0026#34;4. nerdtree窗口:  nerdtree插件非常流行，用来文件管理。\n\u0026#34; NERDTree插件的快捷键nn \u0026lt;silent\u0026gt; \u0026lt;F5\u0026gt; :NERDTreeToggle\u0026lt;CR\u0026gt; 打开/关闭: \u0026lt;F5\u0026gt;切换,一般配置为自动打开。 退出: 切换到nerdtree窗口然后\u0026quot;q\u0026quot;  二、vim 窗口切换:  见配置,ctrl键盘+jkhl:\n\u0026#34; Smart way to move between windows map \u0026lt;C-j\u0026gt; \u0026lt;C-W\u0026gt;j map \u0026lt;C-k\u0026gt; \u0026lt;C-W\u0026gt;k map \u0026lt;C-h\u0026gt; \u0026lt;C-W\u0026gt;h map \u0026lt;C-l\u0026gt; \u0026lt;C-W\u0026gt;l","date":"2021-11-30","img":"","permalink":"https://fabletang.github.io/posts/2021-11-30-vim_windows/","series":["工具"],"tags":["vim"],"title":"vim 窗口相关(三)"},{"categories":["技术"],"content":"一、vim安装插件管理器  早期的vim插件需要在网站下载，然后复制到对应目录.（https://www.vim.org/scripts/index.php 受益于github的发展，用插件管理器(一般使用plug.vim)可以批量自动安装和更新插件。非常方便。 git clone https://github.com/junegunn/vim-plug, 然后复制 plug.vim 到vim目录下的 autoload目录就完成了。\n二、vim配置文件 1.vimrc位置目录  vimrc是vim的总配置文件,windows下为vimrc,linux/macos为.vimrc。一般位于$HOME目录。启动vim,命令行输入:echo $HOME，就可以显示。在此目录下建立vimrc或者.vimrc文件。\n2.vimrc内容  此配置适用macos,其他系统需要少量适配，如果不使用golang,对应插件用\u0026quot;号注释就可以。\n配置中有简要说明.详细介绍请参考github或者本blog其他文章。\nfiletype off \u0026#34; requiredsyntax on\u0026#34;安装 plug插件管理器 \u0026#34;curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#34;然后运行:PlugInstall ,如果遇到下载失败按键R重新执行call plug#begin(\u0026#39;~/.vim/plugged\u0026#39;)Plug \u0026#39;fatih/vim-go\u0026#39;Plug \u0026#39;buoto/gotests-vim\u0026#39;Plug \u0026#39;maralla/completor.vim\u0026#39;Plug \u0026#39;preservim/tagbar\u0026#39;\u0026#34; 快速注释,自动检测语法Plug \u0026#39;preservim/nerdcommenter\u0026#39;\u0026#34; 文件管理插件Plug \u0026#39;preservim/nerdtree\u0026#39;Plug \u0026#39;Xuyuanp/nerdtree-git-plugin\u0026#39;\u0026#34;Plug \u0026#39;ryanoasis/vim-devicons\u0026#39;\u0026#34;git状态显示Plug \u0026#39;airblade/vim-gitgutter\u0026#39;\u0026#34;Plug \u0026#39;mhinz/vim-signify\u0026#39;\u0026#34;文件查找Plug \u0026#39;kien/ctrlp.vim\u0026#39;\u0026#34;文本搜索Plug \u0026#39;dkprice/vim-easygrep\u0026#39;\u0026#34;颜色风格Plug \u0026#39;tomasr/molokai\u0026#39;\u0026#34;括号自动补全Plug \u0026#39;Townk/vim-autoclose\u0026#39;\u0026#34;Plug \u0026#39;Valloric/YouCompleteMe\u0026#39;\u0026#34;代码模版快速生成Plug \u0026#39;SirVer/ultisnips\u0026#39;Plug \u0026#39;honza/vim-snippets\u0026#39;\u0026#34;代码自动补全Plug \u0026#39;Shougo/neocomplete.vim\u0026#39;\u0026#34;历史文件增强 :browse oldfilesPlug \u0026#39;gpanders/vim-oldfiles\u0026#39;\u0026#34; markdown 插件Plug \u0026#39;godlygeek/tabular\u0026#39;Plug \u0026#39;plasticboy/vim-markdown\u0026#39;call plug#end()\u0026#34; 判断系统是否具有“自动命令”（autocmd）的支持\u0026#34;if has(\u0026#39;autocmd\u0026#39;)\u0026#34; 清除所有的自动命令，以方便调试\u0026#34;au!\u0026#34; 对于后缀为“.asm”的文件，认为其是微软的 Macro Assembler 格式\u0026#34; autocmd FileType ruby,eruby set omnifunc=rubycomplete#Complete\u0026#34;endif\u0026#34; 载入文件类型插件filetype plugin indent onfiletype plugin on\u0026#34; 为特定文件类型载入相关缩进文件filetype indent on\u0026#34; colorscheme railscasts\u0026#34; colorscheme fruidle\u0026#34; colorscheme gemcolors\u0026#34;let g:rehash256 = 1\u0026#34;let g:molokai_original = 1colorscheme molokai\u0026#34; colorscheme night\u0026#34; colorscheme twilight\u0026#34;语法样式开启syntax on\u0026#34;set shell=\u0026#39;/bin/bash\u0026#39;\u0026#34;设置字体及大小,需要根据系统字体调整set gfn=Menlo:h16\u0026#34;:set guifont=Menlo:h13\u0026#34; set guifont=Monospace\\ 12\u0026#34; set guifont = Courier\\ 14\u0026#34; set guifont=Bitstream_Vera_Sans_Mono:h10:cANSI\u0026#34;set guifontwide=KaiTi\\ 14\u0026#34;set gfw=幼圆:h10.5:cGB2312\u0026#34; Set to auto read when a file is changed from the outsideset autoread\u0026#34;\u0026#34; With a map leader it\u0026#39;s possible to do extra key combinations\u0026#34; like \u0026lt;leader\u0026gt;w saves the current file let mapleader = \u0026#34;,\u0026#34; let g:mapleader = \u0026#34;,\u0026#34;\u0026#34;\u0026#34; Fast savingnmap \u0026lt;leader\u0026gt;w :w!\u0026lt;cr\u0026gt;set softtabstop=4set expandtab\u0026#34;行间距，如果默认值太小，代码会非常纠结set linespace=4\u0026#34;用\u0026lt;\u0026gt;调整缩进时的长度set shiftwidth=4\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; =\u0026gt; Visual mode related\u0026#34; \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34; \u0026#34; Visual mode pressing * or # searches for the current selection\u0026#34; \u0026#34; Super useful! From an idea by Michael Naumannvnoremap \u0026lt;silent\u0026gt; * :call VisualSelection(\u0026#39;f\u0026#39;)\u0026lt;CR\u0026gt;vnoremap \u0026lt;silent\u0026gt; # :call VisualSelection(\u0026#39;b\u0026#39;)\u0026lt;CR\u0026gt;\u0026#34; history文件中需要记录的行数set history=600\u0026#34; 带有如下符号的单词不要被换行分割\u0026#34; set iskeyword+=_,$,@,%,#,-\u0026#34; 高亮显示普通txt文件（需要txt.vim脚本）\u0026#34;au BufRead,BufNewFile * setfiletype txt\u0026#34; 自动切换文件目录au BufEnter * if expand(\u0026#34;%:h\u0026#34;)!=\u0026#34;\u0026#34;|cd %:h|endif\u0026#34;不需要保持和 vi 非常兼容set nocompatible\u0026#34;执行 Vim 缺省提供的 .vimrc 文件的示例，包含了打开语法加亮显示等最常用的功能\u0026#34;source $VIMRUNTIME/vimrc_example.vim\u0026#34; 使backspace正常处理indent, eol, start等set backspace=indent,eol,start whichwrap+=\u0026lt;,\u0026gt;,[,]\u0026#34; 允许backspace和光标键跨越行边界set whichwrap+=\u0026lt;,\u0026gt;,h,l\u0026#34;在输入命令时列出匹配项目，也就是截图底部的效果set wildmenu\u0026#34;打开自动缩,继承前一行的缩进注释 进set autoindent\u0026#34;默认情况下手动折叠set foldmethod=manual\u0026#34;显示行号（否：nonumber）set number\u0026#34;显示光标的坐标set ruler\u0026#34; 设置光标闪烁\u0026#34;set guicursor=n-c-v:ver50-ncvCursor,-blinkwait175-blinkoff150-blinkon175\u0026#34;set guicursor=n-c-v:hor50-Cursor-ver50-Cursor-blinkwait175-blinkoff650-blinkon350set guicursor=n-c-v:blinkwait100-blinkoff500-blinkon500\u0026#34;set guicursor=n-c-v:ver50-blinkwait175-blinkoff150-blinkon175\u0026#34;不自动换行(否：wrap)\u0026#34; set nowrap\u0026#34;缺省不产生备份文件set nobackup\u0026#34; 不要生成swap文件set noswapfile\u0026#34;set bufhidden=hide\u0026#34;在输入括号时光标会短暂地跳到与之相匹配的括号处，不影响输入set showmatch\u0026#34; 匹配括号高亮的时间（单位是十分之一秒）set matchtime=1\u0026#34; 搜索时不区分大小写\u0026#34; set ignorecase\u0026#34; 在搜索时，输入的词句的逐字符高亮（类似firefox的搜索）set incsearch\u0026#34; 搜索高亮set hlsearch\u0026#34; 不要闪烁set novisualbell\u0026#34; Set 7 lines to the cursor - when moving vertically using j/kset so=7\u0026#34;正确地处理中文字符的折行和拼接set formatoptions+=mM\u0026#34;文件编码自动检测set fileencodings=utf-8,gb18030,ucs-bom,euc-cn,euc-tw,cp936\u0026#34;设置文件格式为unixset fileformat=unix\u0026#34;当使用了图形界面，并且环境变量 LANG 中不含“.”（即没有规定编码）时，把 Vim 的内部编码设为 UTF-8\u0026#34;set encoding=utf-8\u0026#34; set fileencodings=utf-8,gb2312,cp936\u0026#34;set fileencodings=utf-8,gbk,cp936\u0026#34;TAB会被显示成 \u0026#39;\u0026gt;—\u0026#34; 而行尾多余的空白字符显示成 \u0026#39;-\u0026#34;\u0026#34; set listchars=tab:\u0026gt;-,trail:-set list listchars=tab:\u0026gt;-\u0026#34;开启命令显示set showcmd\u0026#34; Don\u0026#39;t redraw while executing macros (good performance config)set lazyredraw\u0026#34;设置窗口大小\u0026#34;set lines=35\u0026#34;set columns=120\u0026#34; 启动的时候不显示那个援助索马里儿童的提示set shortmess=atI\u0026#34; 导出 html 设置\u0026#34;let html_use_css = 1\u0026#34;let html_number_lines = 0\u0026#34;let use_xhtml = 1\u0026#34; Smart way to move between windows map \u0026lt;C-j\u0026gt; \u0026lt;C-W\u0026gt;j map \u0026lt;C-k\u0026gt; \u0026lt;C-W\u0026gt;k map \u0026lt;C-h\u0026gt; \u0026lt;C-W\u0026gt;h map \u0026lt;C-l\u0026gt; \u0026lt;C-W\u0026gt;l\u0026#34;Remap VIM 0 to first non-blank character map 0 ^\u0026#34;\u0026#34; \u0026#34; Move a line of text using ALT+[jk] or Comamnd+[jk] on mac nmap \u0026lt;M-j\u0026gt; mz:m+\u0026lt;cr\u0026gt;`z nmap \u0026lt;M-k\u0026gt; mz:m-2\u0026lt;cr\u0026gt;`z vmap \u0026lt;M-j\u0026gt; :m\u0026#39;\u0026gt;+\u0026lt;cr\u0026gt;`\u0026lt;my`\u0026gt;mzgv`yo`z vmap \u0026lt;M-k\u0026gt; :m\u0026#39;\u0026lt;-2\u0026lt;cr\u0026gt;`\u0026gt;my`\u0026lt;mzgv`yo`z\u0026#34; if has(\u0026#34;mac\u0026#34;) || has(\u0026#34;macunix\u0026#34;) nmap \u0026lt;D-j\u0026gt; \u0026lt;M-j\u0026gt; nmap \u0026lt;D-k\u0026gt; \u0026lt;M-k\u0026gt; vmap \u0026lt;D-j\u0026gt; \u0026lt;M-j\u0026gt; vmap \u0026lt;D-k\u0026gt; \u0026lt;M-k\u0026gt; endif\u0026#34;隐藏底部滚动条set guioptions-=b\u0026#34;隐藏右边滚动条set guioptions-=Rset guioptions-=r\u0026#34;隐藏左边滚动条set guioptions-=lset guioptions-=L\u0026#34;隐藏菜单栏set guioptions-=m\u0026#34;隐藏工具栏set guioptions-=T\u0026#34;设置F2呼出菜单栏\u0026#34;function! ToggleMenuBar()\u0026#34;\techo \u0026#39;ToggleMenuBar\u0026#34;\u0026#34;\tif \u0026amp;guioptions =~# \u0026#39;m\u0026#39;\u0026#34;\tset guioptions-=m\u0026#34;\telse\u0026#34;\tset guioptions+=m\u0026#34;\tendif\u0026#34;endfunction\u0026#34;imap \u0026lt;silent\u0026gt; \u0026lt;C-F12\u0026gt; \u0026lt;C-O\u0026gt;:call ToggleMenuBar()\u0026lt;CR\u0026gt;\u0026#34;map \u0026lt;silent\u0026gt; \u0026lt;C-F12\u0026gt; :call ToggleMenuBar()\u0026lt;CR\u0026gt;\u0026#34;设置工作目录\u0026#34;function! CHANGE_CURR_DIR()\u0026#34;let _dir = expand(\u0026#34;%:p:h\u0026#34;)\u0026#34;exec \u0026#39;cd \u0026#39; . _dir\u0026#34;unlet _dir\u0026#34;endfunction\u0026#34;autocmd BufEnter * call CHANGE_CURR_DIR()\u0026#34; NERDTree插件的快捷键nn \u0026lt;silent\u0026gt; \u0026lt;F5\u0026gt; :NERDTreeToggle\u0026lt;CR\u0026gt;\u0026#34;自动启动nerdtreeautocmd VimEnter * NERDTree | wincmd p\u0026#34;:browse oldfiles 插件增强nmap \u0026lt;leader\u0026gt;b \u0026lt;Plug\u0026gt;(Oldfiles)\u0026#34; F2 通过打开的文件对齐树形目录nn \u0026lt;silent\u0026gt;\u0026lt;F2\u0026gt; :exec(\u0026#34;NERDTree \u0026#34;.expand(\u0026#39;%:h\u0026#39;))\u0026lt;CR\u0026gt;\u0026#34; Check if NERDTree is open or active,打开的文件自动定位目录function! IsNERDTreeOpen() return exists(\u0026#34;t:NERDTreeBufName\u0026#34;) \u0026amp;\u0026amp; (bufwinnr(t:NERDTreeBufName) != -1)endfunction\u0026#34; Call NERDTreeFind iff NERDTree is active, current window contains a modifiable\u0026#34; file, and we\u0026#39;re not in vimdifffunction! SyncTree() if \u0026amp;modifiable \u0026amp;\u0026amp; IsNERDTreeOpen() \u0026amp;\u0026amp; strlen(expand(\u0026#39;%\u0026#39;)) \u0026gt; 0 \u0026amp;\u0026amp; !\u0026amp;diff NERDTreeFind wincmd p endifendfunction\u0026#34; Highlight currently open buffer in NERDTreeautocmd BufEnter * call SyncTree() function! ToggleNerdTree() set eventignore=BufEnter NERDTreeToggle set eventignore=endfunction\u0026#34;CTRL-[ and CTRL-] indent and unindent blocks {{{\u0026#34; inoremap \u0026lt;C-[\u0026gt; \u0026lt;C-O\u0026gt;\u0026lt;LT\u0026gt;\u0026lt;LT\u0026gt;\u0026#34; inoremap \u0026lt;C-]\u0026gt; \u0026lt;C-O\u0026gt;\u0026lt;GT\u0026gt;\u0026lt;GT\u0026gt;\u0026#34; nnoremap \u0026lt;C-[\u0026gt; \u0026lt;LT\u0026gt;\u0026lt;LT\u0026gt;\u0026#34; nnoremap \u0026lt;C-]\u0026gt; \u0026lt;GT\u0026gt;\u0026lt;GT\u0026gt;\u0026#34; vnoremap \u0026lt;C-[\u0026gt; \u0026lt;LT\u0026gt;\u0026#34; vnoremap \u0026lt;C-]\u0026gt; \u0026lt;GT\u0026gt;\u0026#34;}}}\u0026#34; NERD Commenter {{{\u0026#34;let NERDSpaceDelims = 1\u0026#34;map \u0026lt;M-/\u0026gt; \u0026lt;Plug\u0026gt;NERDCommenterToggle\u0026#34;imap \u0026lt;M-/\u0026gt; \u0026lt;C-O\u0026gt;\u0026lt;Plug\u0026gt;NERDCommenterToggle\u0026#34; }}}\u0026#34; 窗口区域切换,F5 后 ↑↓←→ 来切换\u0026#34;imap \u0026lt;silent\u0026gt; \u0026lt;C-left\u0026gt; \u0026lt;esc\u0026gt;\u0026lt;C-W\u0026gt;\u0026lt;left\u0026gt;\u0026#34;vmap \u0026lt;silent\u0026gt; \u0026lt;C-left\u0026gt; \u0026lt;esc\u0026gt;\u0026lt;C-W\u0026gt;\u0026lt;left\u0026gt;\u0026#34;nmap \u0026lt;silent\u0026gt; \u0026lt;C-left\u0026gt; \u0026lt;C-W\u0026gt;\u0026lt;left\u0026gt;\u0026#34;imap \u0026lt;silent\u0026gt; \u0026lt;C-right\u0026gt; \u0026lt;esc\u0026gt;\u0026lt;C-W\u0026gt;\u0026lt;right\u0026gt;\u0026#34;vmap \u0026lt;silent\u0026gt; \u0026lt;C-right\u0026gt; \u0026lt;esc\u0026gt;\u0026lt;C-W\u0026gt;\u0026lt;right\u0026gt;\u0026#34;nmap \u0026lt;silent\u0026gt; \u0026lt;C-right\u0026gt; \u0026lt;C-W\u0026gt;\u0026lt;right\u0026gt;\u0026#34;imap \u0026lt;silent\u0026gt; \u0026lt;C-up\u0026gt; \u0026lt;esc\u0026gt;\u0026lt;C-W\u0026gt;\u0026lt;up\u0026gt;\u0026#34;vmap \u0026lt;silent\u0026gt; \u0026lt;C-up\u0026gt; \u0026lt;esc\u0026gt;\u0026lt;C-W\u0026gt;\u0026lt;up\u0026gt;\u0026#34;nmap \u0026lt;silent\u0026gt; \u0026lt;C-up\u0026gt; \u0026lt;C-W\u0026gt;\u0026lt;up\u0026gt;\u0026#34;imap \u0026lt;silent\u0026gt; \u0026lt;C-down\u0026gt; \u0026lt;esc\u0026gt;\u0026lt;C-W\u0026gt;\u0026lt;down\u0026gt;\u0026#34;vmap \u0026lt;silent\u0026gt; \u0026lt;C-down\u0026gt; \u0026lt;esc\u0026gt;\u0026lt;C-W\u0026gt;\u0026lt;down\u0026gt;\u0026#34;nmap \u0026lt;silent\u0026gt; \u0026lt;C-down\u0026gt; \u0026lt;C-W\u0026gt;\u0026lt;down\u0026gt;\u0026#34; Textmate alt-p \u0026amp; alt+l {{{\u0026#34;inoremap \u0026lt;M-p\u0026gt; params[:]\u0026lt;left\u0026gt;\u0026#34;inoremap \u0026lt;M-j\u0026gt; session[:]\u0026lt;left\u0026gt;\u0026#34;inoremap \u0026lt;M-l\u0026gt; \u0026lt;space\u0026gt;=\u0026gt;\u0026lt;space\u0026gt;\u0026#34;inoremap \u0026lt;M-\u0026gt;\u0026gt; \u0026lt;%=\u0026lt;space\u0026gt;\u0026lt;space\u0026gt;%\u0026gt;\u0026lt;left\u0026gt;\u0026lt;left\u0026gt;\u0026lt;left\u0026gt;\u0026#34; shift+alt+l 选择行\u0026#34;inoremap \u0026lt;M-L\u0026gt; \u0026lt;C-O\u0026gt;\u0026lt;home\u0026gt;v\u0026lt;S-end\u0026gt;\u0026#34;nnoremap \u0026lt;M-L\u0026gt; \u0026lt;home\u0026gt;v\u0026lt;S-end\u0026gt;\u0026#34; shift+alt+k 删除行\u0026#34;inoremap \u0026lt;M-K\u0026gt; \u0026lt;C-O\u0026gt;\u0026lt;home\u0026gt;v\u0026lt;S-end\u0026gt;\u0026lt;del\u0026gt;\u0026#34;nnoremap \u0026lt;M-K\u0026gt; \u0026lt;home\u0026gt;v\u0026lt;s-end\u0026gt;\u0026lt;del\u0026gt;\u0026#34; ctrl + c,a,v,x,z\u0026#34;nnoremap \u0026lt;BS\u0026gt; d\u0026#34; ctrl + anoremap \u0026lt;C-A\u0026gt; ggVGinoremap \u0026lt;C-A\u0026gt; \u0026lt;C-O\u0026gt;ggVG\u0026#34; ctrl + s\u0026#34;imap \u0026lt;C-s\u0026gt; \u0026lt;Esc\u0026gt;:w\u0026lt;CR\u0026gt;:echo expand(%f\u0026#34;) . \u0026#39; saved.\u0026#34;\u0026lt;CR\u0026gt;\u0026#34;vmap \u0026lt;C-s\u0026gt; \u0026lt;Esc\u0026gt;:w\u0026lt;CR\u0026gt;:echo expand(%f\u0026#34;) . \u0026#39; saved.\u0026#34;\u0026lt;CR\u0026gt;\u0026#34;nmap \u0026lt;C-s\u0026gt; :w\u0026lt;CR\u0026gt;:echo expand(%f\u0026#34;) . \u0026#39; saved.\u0026#34;\u0026lt;CR\u0026gt;\u0026#34; ctrl + n\u0026#34;imap \u0026lt;C-n\u0026gt; \u0026lt;esc\u0026gt;:enew!\u0026lt;CR\u0026gt;\u0026#34;nmap \u0026lt;C-n\u0026gt; :enew!\u0026lt;CR\u0026gt;\u0026#34;vmap \u0026lt;C-n\u0026gt; \u0026lt;esc\u0026gt;:enew!\u0026lt;CR\u0026gt;\u0026#34; ctrl + c\u0026#34;vmap \u0026lt;C-c\u0026gt; \u0026#34;+y\u0026#34; ctrl + x\u0026#34; vmap \u0026lt;C-x\u0026gt; \u0026#34;+x\u0026#34; ctrl + z\u0026#34;inoremap \u0026lt;C-z\u0026gt; \u0026lt;C-O\u0026gt;uinoremap \u0026lt;C-z\u0026gt; unnoremap \u0026lt;C-z\u0026gt; u\u0026#34; ctrl + y\u0026#34;inoremap \u0026lt;C-y\u0026gt; \u0026lt;C-O\u0026gt;\u0026lt;C-R\u0026gt;\u0026#34;nnoremap \u0026lt;C-y\u0026gt; \u0026lt;C-R\u0026gt;\u0026#34; ctrl + vnnoremap \u0026lt;C-v\u0026gt; \u0026#34;+gPinoremap \u0026lt;C-v\u0026gt; \u0026#34;+gP\u0026#34;inoremap \u0026lt;C-v\u0026gt; \u0026lt;C-O\u0026gt;\u0026#34;+gP\u0026#34; ctrl + f\u0026#34;imap \u0026lt;C-f\u0026gt; \u0026lt;esc\u0026gt;:/\u0026#34;nmap \u0026lt;C-f\u0026gt; :/\u0026#34; ctrl + r\u0026#34;imap \u0026lt;C-r\u0026gt; \u0026lt;esc\u0026gt;:%s/\u0026#34;vmap \u0026lt;C-r\u0026gt; \u0026lt;esc\u0026gt;:%s/\u0026#34;nmap \u0026lt;C-r\u0026gt; :%s/\u0026#34; ctrl + o\u0026#34;imap \u0026lt;C-o\u0026gt; \u0026lt;C-O\u0026gt;:e\u0026#34;vmap \u0026lt;C-o\u0026gt; \u0026lt;esc\u0026gt;:e\u0026#34;nmap \u0026lt;C-o\u0026gt; :e\u0026#34;}}}\u0026#34; 自定义命令\u0026#34;command Delnullrow :%s/^\\n$//g\u0026#34; 自动完成设置 禁止在插入模式移动的时候出现 Complete 提示let g:acp_mappingDriven = 1\u0026#34; 自动除去空格\u0026#34; Remove trailing whitespace when writing a buffer, but not for diff files.\u0026#34; %s/^\\n$//g 删除两个以上空行\u0026#34; From: Vigil\u0026#34;function RemoveTrailingWhitespace()\u0026#34; if \u0026amp;ft != \u0026#39;diff\u0026#39;\u0026#34; let b:curcol = col(\u0026#34;.\u0026#34;)\u0026#34; let b:curline = line(\u0026#34;.\u0026#34;)\u0026#34; silent! %s/\\s\\+$//\u0026#34; silent! %s/\\(\\s*\\n\\)\\+\\%$//\u0026#34; call cursor(b:curline, b:curcol)\u0026#34; endif\u0026#34;endfunction\u0026#34;autocmd BufWritePre * call RemoveTrailingWhitespace()\u0026#34; 括号自动补全\u0026#34;:inoremap ( ()\u0026lt;ESC\u0026gt;i\u0026#34;:inoremap ) \u0026lt;c-r\u0026gt;=ClosePair(\u0026#39;)\u0026#39;)\u0026lt;CR\u0026gt;\u0026#34;:inoremap { {}\u0026lt;ESC\u0026gt;i\u0026#34;:inoremap } \u0026lt;c-r\u0026gt;=ClosePair(\u0026#39;}\u0026#39;)\u0026lt;CR\u0026gt;\u0026#34;:inoremap [ []\u0026lt;ESC\u0026gt;i\u0026#34;:inoremap ] \u0026lt;c-r\u0026gt;=ClosePair(\u0026#39;]\u0026#39;)\u0026lt;CR\u0026gt;\u0026#34;:inoremap \u0026lt; \u0026lt;\u0026gt;\u0026lt;ESC\u0026gt;i\u0026#34;:inoremap \u0026gt; \u0026lt;c-r\u0026gt;=ClosePair(\u0026#39;\u0026gt;\u0026#39;)\u0026lt;CR\u0026gt;\u0026#34;function ClosePair(char)\u0026#34; if getline(\u0026#39;.\u0026#39;)[col(\u0026#39;.\u0026#39;) - 1] == a:char\u0026#34; return \u0026#39;\\\u0026lt;Right\u0026gt;\u0026#39;\u0026#34; else\u0026#34; return a:char\u0026#34; endif\u0026#34;endf\u0026#34; go 1.0.3\u0026#34; gocode 配置 gocode status确认是否启动set completeopt=longest,menu\u0026#34; gocode 自动补全 快捷键冲突 所以设置为 ctrl+h\u0026#34;imap \u0026lt;C-h\u0026gt; \u0026lt;C-x\u0026gt;\u0026lt;C-o\u0026gt;imap \u0026lt;C-h\u0026gt; \u0026lt;C-x\u0026gt;\u0026lt;C-o\u0026gt;\u0026#34; go 相关的快捷键 格式化 gofmt\u0026#34;:map \u0026lt;F9\u0026gt; \u0026lt;Esc\u0026gt;:w\u0026lt;CR\u0026gt;:!gofmt -s -w %\u0026lt;CR\u0026gt;:e %\u0026lt;CR\u0026gt;\u0026#34;:imap \u0026lt;F9\u0026gt; \u0026lt;Esc\u0026gt;:w\u0026lt;CR\u0026gt;:!gofmt -s -w %\u0026lt;CR\u0026gt;:e %\u0026lt;CR\u0026gt;\u0026#34;:map \u0026lt;F9\u0026gt; \u0026lt;Esc\u0026gt;:w\u0026lt;CR\u0026gt;:!gofmt -s -w %\u0026lt;CR\u0026gt;:e %\u0026lt;CR\u0026gt;\u0026#34;autocmd BufWritePre,FileWritePre *.go ks|execute \u0026#39;:w\u0026#39;|execute \u0026#39;:!gofmt -s -w %\u0026#39;|execute \u0026#39;:e %\u0026#39;|execute \u0026#39;source ~/.vimrc\u0026#39;|\u0026#39;s\u0026#34;autocmd BufWritePre,FileWritePre *.go ks|execute \u0026#39;:w\u0026#39;|execute \u0026#39;:!gofmt -s -w %\u0026#39;|execute \u0026#39;:e %\u0026#39;|\u0026#39;s\u0026#34;autocmd BufWritePost *.go execute \u0026#39;:!gofmt -s -w % \u0026#39;|execute \u0026#39;:e %\u0026#39;\u0026#34;autocmd BufWritePre *.go execute \u0026#39;:!gofmt -s -w % \u0026#39;|execute \u0026#39;:e %\u0026#39;\u0026#34;:map \u0026lt;F9\u0026gt; \u0026lt;C-s\u0026gt;:!gofmt -s -w %\u0026lt;CR\u0026gt;:e %\u0026lt;CR\u0026gt;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;设置在c文件保存时自动格式化\u0026#34;\u0026#34;调用命令是 au BufWritePost *.c :call FormatC()function! FormatGo()\u0026#34;execute \u0026#39;:w\u0026#39; execute \u0026#39;:!gofmt -s -w %\u0026#39; edit syntax enableendfunction\u0026#34; go 相关的快捷键 编译和运行 go run\u0026#34; au BufWritePost *.go :call FormatGo():imap \u0026lt;F9\u0026gt; \u0026lt;Esc\u0026gt;:w\u0026lt;CR\u0026gt;:!go run %\u0026lt;CR\u0026gt;:map \u0026lt;F9\u0026gt; \u0026lt;Esc\u0026gt;:w\u0026lt;CR\u0026gt;:!go run %\u0026lt;CR\u0026gt;\u0026#34;:imap \u0026lt;F10\u0026gt; \u0026lt;Esc\u0026gt;:!go run %\u0026lt;CR\u0026gt;\u0026#34;:map \u0026lt;F10\u0026gt; \u0026lt;Esc\u0026gt;:!go run %\u0026lt;CR\u0026gt;\u0026#34;:imap \u0026lt;F9\u0026gt; \u0026lt;Esc\u0026gt;:w\u0026lt;CR\u0026gt;:!go test\u0026lt;CR\u0026gt;\u0026#34;:map \u0026lt;F9\u0026gt; \u0026lt;Esc\u0026gt;:w\u0026lt;CR\u0026gt;:!go test\u0026lt;CR\u0026gt;\u0026#34;:imap \u0026lt;F8\u0026gt; \u0026lt;Esc\u0026gt;:!go test\u0026lt;CR\u0026gt;\u0026#34;:map \u0026lt;F8\u0026gt; \u0026lt;Esc\u0026gt;:!go test\u0026lt;CR\u0026gt;\u0026#34;:imap \u0026lt;F7\u0026gt; \u0026lt;Esc\u0026gt;:!go install\u0026lt;CR\u0026gt;\u0026#34;:map \u0026lt;F7\u0026gt; \u0026lt;Esc\u0026gt;:!go install\u0026lt;CR\u0026gt;nmap \u0026lt;F8\u0026gt; :TagbarToggle\u0026lt;CR\u0026gt;let g:tagbar_width=25let g:tagbar_type_go = { \\ \u0026#39;ctagstype\u0026#39; : \u0026#39;go\u0026#39;, \\ \u0026#39;kinds\u0026#39; : [ \\ \u0026#39;p:package\u0026#39;, \\ \u0026#39;i:imports:1\u0026#39;, \\ \u0026#39;c:constants\u0026#39;, \\ \u0026#39;v:variables\u0026#39;, \\ \u0026#39;t:types\u0026#39;, \\ \u0026#39;n:interfaces\u0026#39;, \\ \u0026#39;w:fields\u0026#39;, \\ \u0026#39;e:embedded\u0026#39;, \\ \u0026#39;m:methods\u0026#39;, \\ \u0026#39;r:constructor\u0026#39;, \\ \u0026#39;f:functions\u0026#39; \\ ], \\ \u0026#39;sro\u0026#39; : \u0026#39;.\u0026#39;, \\ \u0026#39;kind2scope\u0026#39; : { \\ \u0026#39;t\u0026#39; : \u0026#39;ctype\u0026#39;, \\ \u0026#39;n\u0026#39; : \u0026#39;ntype\u0026#39; \\ }, \\ \u0026#39;scope2kind\u0026#39; : { \\ \u0026#39;ctype\u0026#39; : \u0026#39;t\u0026#39;, \\ \u0026#39;ntype\u0026#39; : \u0026#39;n\u0026#39; \\ }, \\ \u0026#39;ctagsbin\u0026#39; : \u0026#39;gotags\u0026#39;, \\ \u0026#39;ctagsargs\u0026#39; : \u0026#39;-sort -silent\u0026#39;\\ }\u0026#34; shortcuts to make it easier to jump between errors in quickfix list:map \u0026lt;C-n\u0026gt; :cnext\u0026lt;CR\u0026gt;map \u0026lt;C-m\u0026gt; :cprevious\u0026lt;CR\u0026gt;nnoremap \u0026lt;leader\u0026gt;o :copen\u0026lt;CR\u0026gt;nnoremap \u0026lt;leader\u0026gt;oo :cclose\u0026lt;CR\u0026gt;au FileType go nmap \u0026lt;Leader\u0026gt;i \u0026lt;Plug\u0026gt;(go-info)au FileType go nmap \u0026lt;Leader\u0026gt;gd \u0026lt;Plug\u0026gt;(go-doc)au FileType go nmap \u0026lt;Leader\u0026gt;gv \u0026lt;Plug\u0026gt;(go-doc-vertical)au FileType go nmap \u0026lt;Leader\u0026gt;gb \u0026lt;Plug\u0026gt;(go-doc-browser)au FileType go nmap \u0026lt;leader\u0026gt;r \u0026lt;Plug\u0026gt;(go-run)\u0026#34;au FileType go nmap \u0026lt;leader\u0026gt;b \u0026lt;Plug\u0026gt;(go-build)\u0026#34; au FileType go nmap \u0026lt;leader\u0026gt;t \u0026lt;Plug\u0026gt;(go-test)au FileType go nmap \u0026lt;leader\u0026gt;t \u0026lt;Plug\u0026gt;(go-test)\u0026#34; au FileType go nmap \u0026lt;leader\u0026gt;t \u0026lt;Plug\u0026gt;(go-test-compile)\u0026#34; au FileType go nmap \u0026lt;leader\u0026gt;c \u0026lt;Plug\u0026gt;(go-coverage)au FileType go nmap gd \u0026lt;Plug\u0026gt;(go-def)au FileType go nmap gc \u0026lt;Plug\u0026gt;(go-callers)au FileType go nmap gf \u0026lt;Plug\u0026gt;(go-referrers)au FileType go nmap gs \u0026lt;Plug\u0026gt;(go-implements)au FileType go nmap \u0026lt;Leader\u0026gt;ds \u0026lt;Plug\u0026gt;(go-def-split)au FileType go nmap \u0026lt;Leader\u0026gt;dv \u0026lt;Plug\u0026gt;(go-def-vertical)au FileType go nmap \u0026lt;Leader\u0026gt;dt \u0026lt;Plug\u0026gt;(go-def-tab)\u0026#34;Rename the identifier under the cursor to a new nameau FileType go nmap \u0026lt;Leader\u0026gt;e \u0026lt;Plug\u0026gt;(go-rename)au FileType go nmap \u0026lt;leader\u0026gt;l \u0026lt;Plug\u0026gt;(go-lint)let g:UltiSnipsExpandTrigger=\u0026#34;\u0026lt;tab\u0026gt;\u0026#34;\u0026#34;let g:UltiSnipsJumpForwardTrigger=\u0026#34;\u0026lt;c-b\u0026gt;\u0026#34;\u0026#34;let g:UltiSnipsJumpBackwardTrigger=\u0026#34;\u0026lt;c-z\u0026gt;\u0026#34;\u0026#34;Disable opening browser after posting to your snippet to play.golang.org:\u0026#34;let g:go_play_open_browser = 0\u0026#34;\u0026#34;By default vim-go shows errors for the fmt command, to disable it:\u0026#34;let g:go_fmt_fail_silently = 1\u0026#34;\u0026#34;Enable goimports to automatically insert import paths instead of gofmt:let g:go_fmt_command = \u0026#34;goimports\u0026#34;\u0026#34;let g:go_term_enabled=0\u0026#34;let g:go_term_enabled = 1\u0026#34;let g:go_term_mode=\u0026#39;split\u0026#39;\u0026#34;let g:go_term_reuse = 1\u0026#34;let g:go_term_mode=\u0026#39;vsplit\u0026#39;\u0026#34;let g:go_term_mode=\u0026#39;tab\u0026#39;\u0026#34;let g:go_term_close_on_exit = 1\u0026#34;let g:go_test_show_name = 1\u0026#34;Disable auto fmt on save:let g:go_fmt_autosave = 1let g:go_autodetect_gopath = 1let g:godef_split=2let g:go_list_type = \u0026#34;quickfix\u0026#34;\u0026#34;let g:UltiSnipsJumpBackwardTrigger=\u0026#34;\u0026lt;c-z\u0026gt;\u0026#34;\u0026#34;let g:go_highlight_types = 1let g:go_highlight_extra_types = 1let g:go_highlight_fields = 1let g:go_highlight_function_calls = 1let g:go_highlight_functions = 1let g:go_highlight_methods = 1let g:go_highlight_structs = 1let g:go_highlight_operators = 1let g:go_highlight_build_constraints = 1let g:go_highlight_generate_tags = 1let g:go_version_warning = 1\u0026#34;let g:go_def_mode=\u0026#39;gopls\u0026#39;\u0026#34;let g:go_info_mode=\u0026#39;gopls\u0026#39;\u0026#34; Enable lsp for go by using goplslet g:completor_filetype_map = {}let g:completor_filetype_map.go = {\u0026#39;ft\u0026#39;: \u0026#39;lsp\u0026#39;, \u0026#39;cmd\u0026#39;: \u0026#39;gopls -remote=auto\u0026#39;}let g:go_metalinter_enabled = [\u0026#39;vet\u0026#39;, \u0026#39;golint\u0026#39;, \u0026#39;errcheck\u0026#39;]\u0026#34;By default binaries are installed to $GOBIN or $GOPATH/bin. To change it:\u0026#34;\u0026#34;let g:go_bin_path = expand(\u0026#34;~/.gotools\u0026#34;)\u0026#34;\u0026#34;snippet 代码模板参考\u0026#34;https://github.com/honza/vim-snippets/blob/master/snippets/go.snippets\u0026#34;\u0026#34;\u0026#34; If you would like JSX in .js fileslet g:jsx_ext_required = 0\u0026#34; md keyboard\u0026#34;let g:mkdp_path_to_chrome = \u0026#34;open -a Google\\\\ Chrome\u0026#34;\u0026#34;MarkdownPreview\u0026#34; 在打开 markdown 文件后，使用该命令可以打开预览窗口\u0026#34;\u0026#34; MarkdownPreviewStop\u0026#34; \u0026#34; 关闭 markdown 预览窗口，并停止开启的服务进程\u0026#34; gitgutterlet g:gitgutter_preview_win_floating = 1\u0026#34;autocmd BufWritePost * GitGutterset updatetime=500\u0026#34;markdownlet g:vim_markdown_folding_disabled = 1三、安装插件  命令行模式:PlugInstall, 耐心等待结果，部分失败的话，大写R键(shift+r) 重新安装，直至呈现下图: ","date":"2021-11-24","img":"","permalink":"https://fabletang.github.io/posts/2021-11-24-vim_conf/","series":["工具"],"tags":["vim"],"title":"vim 配置(二)"},{"categories":["技术"],"content":"一、vim起源  vim至今30年历史了，vim是\u0026quot;Vi Improved\u0026quot;的缩写，由vi发展而来.\nvi是unix系统默认编辑器，当时没有鼠标，键盘的按键也较少，比如方向键/Cap等就没有。所以当时的人们(主要是贝尔实验室)创造一个纯键盘的文字编辑器。意外的是，经过几十年的验证，纯粹键盘操作比居然比鼠标更加便捷高效。\n甚至有vim狂热喜爱者喊出口号：世上的编辑器分两种，一种是vim，一种是其他。^_^\n二、vim介绍  以下vim默认为vim8.1+版本。\n1.vim界面  通常的vim界面如下图。左边是文件列表(nerdtree插件效果)，右底下是quickfix区域，一般显示查找运行结果/查找结果列表之类。右边面积最大的为文本编辑区。 2.vim模式  模式是为了让vim知道当前的按键是文本输入还是其他操作功能(光标移动/标签等等).常用四种模式,如下图。\n可以观察到，任何情况下，按esc键就回到普通模式了。所以esc键使用频率非常高（甚至有人专门发明esc脚踏板）。 三、vim学习 1.vim安装  建议安装GUI图形界面的vim,文本渲染比控制台下的要快一点。\n windows: https://www.vim.org/download.php#pc  macos: https://github.com/macvim-dev/macvim/releases   2.vim练习  网上有大量vim入门教程，但是建议用vim自带的vimtutor学习。vim键盘命令非常多，死记硬背是比较难的，结合教程，在使用中记忆，让肌肉形成条件反射。3-5天就比较熟练了。在控制台(console)提示符下，输入vimtutor,或者vim命令模式下:vimtutor,注意键盘要切换为英文小写。如下图: 四、vim常用键盘命令图 ","date":"2021-11-22","img":"","permalink":"https://fabletang.github.io/posts/2021-11-22-vim_tutor/","series":["工具"],"tags":["vim"],"title":"vim 入门(一)"},{"categories":["技术"],"content":"目前golang最新版本为1.17.3，经过12年的发展，生态已经成熟。\nGo是一门工程语言 go诞生的初衷就是解决c/c++的各种弊端，提高生产力。\n go编译速度极快，相对于c++/rust,10倍以上编译速度。 go fmt 代码格式化,代码风格统一。 自动垃圾搜集。简化c/c++的内存管理。 单一执行文件。  Go与其他语言的区别 Go vs Java:  Go有内存垃圾自动处理，无虚拟机。 Go无对象编程的类class的概念，更强调struct（类似C）. Go的对象继承是“鸭子原理\u0026quot;,Java是“血缘关系\u0026quot;.  Go vs C:  Go无宏定义.兼容C。基本上可以用C的风格来写Go代码。  Go vs C++:  C++ 20是一门现代语言，有非常多的特性，Go语言是以C为参考的，所以大多数特性Go都不具备，比如虚函数等。  Go vs Rust:  Rust是在Go诞生后出现的，Go语法简单，Rust语法复杂。Rust强调严格的内存安全，Go的自动垃圾搜集是宽松的内存管理。Rust具备大多数现代语言特性，其复杂性与C++相当。  Go vs javascript/typescript/php:  Go 是强类型语言，性能高很多。  Go的优势 语法简洁 简洁不意味简单，但是编码效率高,清晰易懂也减少维护成本。  性能优异 性能介于c++/rust 与 Java之间。2倍以上java性能。  生态丰富，开发效率高  基础类库多,经过12年的发展，驱动/扩展库也多 开发工具成熟,包管理go mod,编程IDE:goland/vscode/vim-go 开发资料丰富，常见问题大部分已经可以baidu/google.  建议掌握的编程要点  多值返回 函数式编程 单元测试 goroutine sync channel reflect context库 web框架gin Generic泛型(go 1.18) ORM框架 gomybatis log组件 zap 配置组件 viper  ","date":"2021-11-18","img":"","permalink":"https://fabletang.github.io/posts/2021-11-18-introduce_of_golang/","series":["编程"],"tags":["golang"],"title":"Golang介绍"},{"categories":null,"content":"最近“元宇宙\u0026quot;炒的火热，随着facebook公司改名为meta以后更是达到了高潮。 元宇宙英文原词“Metaverse”，出自尼尔·斯蒂芬森1992 年的科幻小说《雪崩》， 在这部小说中讲述了大量有关虚拟化身、赛博朋克等场景。 可以简单认为是VR虚拟现实的进化版,虚拟现实只是暂时进入，而元宇宙是具备独立意识的第二生命空间。\n最近《三体》作者强烈反对“元宇宙”，他认为这是个错误的道路，应该实体探索星空。 我赞同他的呼吁，但是元宇宙很难避免,必然出现，恐怕最好的结果是原宇宙中的意识去探索星空。\n大胆给出以下观点:\n 元宇宙将出现，届时实体人类将灭亡。 元宇宙需满足以下条件:  人工智能已经实现。 智能生命相关伦理和法规成熟。 能源无尽，人类基本生活需求已经满足。   人工智能20年以内都难以实现，元宇宙更将遥遥无期，至少看到这篇文章的你,有生之年希望渺茫。  为什么元宇宙必然出现: 人性角度 人是欲望的集合体，欲望是生存的支柱。脱离肉体，欲望更有放飞的空间。大部分人连游戏/赌博/旅游/购物这样的满足感都抵御不了，怎么能抵抗梦里成真的诱惑？怎么能抵抗永生的诱惑?\n为什么元宇宙出现后人类将灭亡: 可以参考电影《黑客帝国》\n人性角度 假如元宇宙的人也具备人性，当元宇宙的你知道可以被现实世界的你摧毁，会发生什么？谁更可能取胜？不同于电影的英雄主义宣传，我悲观认为在这个新的黑客帝国，智能生命将取胜。\n物种角度 假如元宇宙的人是独立的智能生命,他们将形成新的种族或者阶级，这样的团体会认为虚弱、智力低下的现实人类是同一种族吗？现实社会的你会喜欢吸血的臭虫吗？\n元宇宙需要很强大的技术基础,很长时间内都难以满足:  内容如此丰富的元宇宙，很难想象没有强大的人工智能在维护。 现在的AI技术是很低级的，物品识别都有较大错误率(参见自动驾驶)，智能推断更是呆板(参见军用无人机)。 再往前考察所需技术，3D实时成像。3D实时成像的物理基础不存在， 2016的VR泡沫破灭，是因为最强大的显卡制造商Nvidia宣布不生产便携式的眼镜大小的显卡,显然当时是技术达不到。即使到2021年末的今天，显示卡的性能还是达不到，Nvidia还是没生产或者研发这种实体小、性能强、功耗少的显示卡。 3D实时成像从软件上来看也是行不通，目前的图形渲染技术的基本元素是三角形,要达到接近现实的效果，需要以像素点来渲染，然而这样的图形渲染算法目前都没有应用。 交互技术不成熟, 目前玩游戏用的是键盘和鼠标/触摸板以及麦克风。显然做不到逼真、实时的交互。 再往低层技术考察，操作系统。目前最先进的应该是linux. 但是这个每年都能发现0day bug的系统能承载一个虚拟世界？现在根本没有千万人在同一服务器的游戏。 继续往低层技术考察，编程语言还处于争论阶段，目前还没有一种效率高、难度低、安全高的语言。rust?语法还在变化，特性还在频繁增加的语言能叫成熟？rust能写操作系统吗? rust语言的难度甚至超过c++.  ","date":"2021-11-11","img":"","permalink":"https://fabletang.github.io/posts/2021-11-11-metaverse/","series":null,"tags":["others"],"title":"元宇宙的一些判断"},{"categories":["技术"],"content":"关系型数据库是绝大多数系统的数据核心,这个关键设施也往往是性能的瓶颈。以下是一些使用建议。\n按业务场景设计表结构 业务场景: 一个mysql的用户表，1000万条记录，如何查询出当天生日的用户？\n表结构通用规则  所有字段必须非空而且有默认值。 一般都有创建时间和更新时间字段，mysql5.6+ 支持数据库本身更新此字段。 尽可能不使用TEXT、BLOB类型. 表字符集尽量选择UTF8MB4,mysql的utf8不是标准的字符集，utf8mb4可以存储表情字符。 索引字段尽可能使用int/long, 索引为字符型不能超过32个字符。 注释尽量清楚 建表的时候应该考虑最终的数据量，mysql单表应该不超过1000万,分布式数据库按业务字段分区。 不使用外键，尽量少用联合唯一束缚。联合主键酌情使用。  查询最佳实践 互联网业务场景,数据库瓶颈一般出现在查询。\n 查询一般不关联超过3个表。 查询扫码记录数超过10万条，必须命中索引。 避免使用inner join，left join 语句中的主表应该是结果数据量最少的表。 where语句最左原则，最靠近where的条件应该是索引，应该是可以最大限度缩小查询范围的条件。 避免破坏索引的不规范语句，比如id=\u0026lsquo;1\u0026rsquo;,类型转换会忽略索引,比如 like %xxx%,模糊匹配也会破坏索引。 尽量少用数据库特殊函数，影响性能也不好迁移。 尽量少用group by/max/sum,如果是高频调用的sql, 意味着表结构不合理。 禁止使用 select *，不知道需要返回的字段，意味着不理解业务。  通用最佳实践  查询语句复杂，往往是缺状态字段或者缺统计表。 应该手写sql,反对使用所谓面向对象的orm中间件，比如hibernate,mybaits-plus。 单个api的sql语句一般不超过3条。 3次以上数据库交互，响应速度就很差。 读写分离,实时性要求不高的查询，应该走从库。互联的mysql 一般是1主3+从. 数据强一致,并且并发高的情况下(间隙锁)，事务提交不能解决问题的话，考虑乐观事务(version字段)以及分布式全局锁（redis/zookeeper）  ","date":"2021-11-09","img":"","permalink":"https://fabletang.github.io/posts/2021-11-09-practice_of_db/","series":["概念"],"tags":["practice"],"title":"关系型数据库实践"},{"categories":["管理"],"content":" 管理  一、管理的历史  奴隶社会 封建社会 现代社会  工业：流水线\\六西格玛\\丰田管理(看板) 软件开发： 瀑布式\\快速迭代\\XP极限编程\\scrum敏捷开发    二、人性  三字经，人之初，性本善。  三、OKR ","date":"2021-04-22","img":"","permalink":"https://fabletang.github.io/posts/2021-04-22-methodology_2/","series":["心得"],"tags":["project"],"title":"技术管理-管理、人性与OKR"},{"categories":["技术"],"content":"java单例模式有5种实现方式,推荐以下3种方式. 一、单例-饿汉式: 特点:线程安全，不能延时加载\npublic enum SingletonDemo1 { //枚举元素本身就是单例  INSTANCE; //添加自己需要的操作  public void singletonOperation(){ } } 二、单例-懒汉式-双重锁检查: 特点:线程安全，延时加载。 ps: java1.5后,volatile可以避免jvm初始化内存分配可能乱序的问题。\npublic class SingletonDemo2 { private static volatile SingletonDemo2 SingletonDemo2; private SingletonDemo2() { } public static SingletonDemo2 newInstance() { if (SingletonDemo2 == null) { synchronized (SingletonDemo2.class) { if (SingletonDemo2 == null) { SingletonDemo2 = new SingletonDemo2(); } } } return SingletonDemo2; } } 三、单例-懒汉式-静态内部类: 特点:线程安全，延时加载。\npublic class SingletonDemo3 { private static class SingletonClassInstance{ private static final SingletonDemo3 instance=new SingletonDemo3(); } private SingletonDemo3(){} public static SingletonDemo3 getInstance(){ return SingletonClassInstance.instance; } } 四、多例: 多例模式，我们可以将类的实例都编上号，然后将实例存放在一个Map:\npublic class MultiInstance { // 实例编号  private long instanceNum; // 用于存放实例  private static final Map\u0026lt;Long, MultiInstance\u0026gt; ins = new HashMap\u0026lt;\u0026gt;(); static { // 存放 3 个实例  ins.put(1L, new MultiInstance(1)); ins.put(2L, new MultiInstance(2)); ins.put(3L, new MultiInstance(3)); } private MultiInstance(long n) { this.instanceNum = n; } public MultiInstance getInstance(long n) { return ins.get(n); } } 实际上,Java 中的枚举就是一个“天然”的多例模式,其中的每一项代表一个实例:\npublic enum MultiInstance { ONE, TWO, THREE; } 五、线程中的单例: 一般情况下，我们所说的单例的作用范围是进程唯一的，就是在一个进程范围内，一个类只允许创建一个对象，进程内的多个线程之间也是共享同一个实例。 那么线程唯一的单例就是，一个实例只能被一个线程拥有，一个进程内的多个线程拥有不同的类实例。 我们同样可以用 ConcurrentHashMap 来实现:\npublic class ThreadSingleton { private static final ConcurrentHashMap\u0026lt;Long, ThreadSingleton\u0026gt; instances = new ConcurrentHashMap\u0026lt;\u0026gt;(); private ThreadSingleton() {} public static ThreadSingleton getInstance() { Long id = Thread.currentThread().getId(); instances.putIfAbsent(id, new ThreadSingleton()); return instances.get(id); } } ","date":"2021-02-26","img":"","permalink":"https://fabletang.github.io/posts/2021-02-26-java_singleten_pattern/","series":["编程"],"tags":["java"],"title":"java模式:单例/多例/线程单例"},{"categories":["管理"],"content":" 很多技术人不喜欢管理，就像古代书生怕碰到铜钱，沾染了“铜臭”变得不纯洁了。 管理，第一是对自我的管理,自己的工作方式。不要把管理想象成奴役他人的皮鞭，可以认为管理首先是规范自己的 戒尺，然后把这根戒尺变成指挥棒去协调团队。 某些同学看了这些书，甚至考试认证都过了，还是没找到管理的感觉。 今天跟大家探讨一下，怎么学习管理理论。  一、学习的广度  站在巨人肩膀上做事是理所当然的，所以管理相关的理论知识要先学习。这方面的权威书籍有很多， 比如国家软件项目管理考试、国际pmp项目管理认证,都是很好的教材，这些教材每年都有更新，比如scrum都包含在内。 网络上有最新的管理方法，比如OKR.这些也需要了解,现在信息交流快捷，几年就会变换一种主流管理方法。  二、学习的深度  理工科毕业的技术人讲究“实证\u0026quot;,对书本上泛泛而论的管理方法很难产生共鸣，自己都不信的理论，当然就很难在 实际工作中运用。 但是我们可以采用数理的逻辑来印证管理理论: 比如“过程管理\u0026quot;,很多管理方法都提到这个词，为什么一定要“过程管理“解释得并不通透， 如果联系到理工科都学过的“工业自动化”的“闭环反馈\u0026quot;就容易明白了。 又比如“扁平式组织结构”，如果联系到 “信息论\u0026quot;里的“任何信息传递、转换都会有损耗”, 就很容易理解层级少的组织可以减少沟通成本。  三、以人为本  管理是对人的规则。 人是不一样的，同样的人在不同时期也是不一样的。所以大家可以观察到主流管理方法会随时间 而淘汰，不同行业的主流管理方法也不一样。体察人性，与对应的管理方法对应起来，深刻领会原因, 这样就会\u0026quot;相信\u0026quot;, 只有你“信”，才能影响他人。  ","date":"2021-02-17","img":"","permalink":"https://fabletang.github.io/posts/2021-02-17-methodology_1/","series":["心得"],"tags":["project"],"title":"技术管理-怎么学"},{"categories":["技术"],"content":"一、docker rmi:  使用多个images id删除,前四位、空格区分  docker rmi 861b 7d51 过滤批量删除镜像, 对docker images 显示的行进行过滤。   根据tag名删除  docker rmi -f $(docker images | grep \u0026#34;fabletang/test-*\u0026#34; | awk \u0026#34;{print \\$3}\u0026#34;) docker rmi -f $(docker images | grep \u0026#34;\u0026lt;none\u0026gt;\u0026#34; | awk \u0026#34;{print \\$3}\u0026#34;)  根据版本号删除  docker rmi -f $(docker images | grep \u0026#34;0.0.1\u0026#34; | awk \u0026#34;{print \\$3}\u0026#34;)  根据Tag和版本号删除  docker rmi -f $(docker images | grep \u0026#34;fabletang/service-java\u0026#34; | awk -F\u0026#39; 0.\u0026#39; \u0026#39;{if ($2\u0026lt;0.6) print $0}\u0026#39; | awk \u0026#34;{print \\$3}\u0026#34;)  删除所有未运行 Docker 容器  docker rm $(docker ps -a -q) ","date":"2017-09-16","img":"","permalink":"https://fabletang.github.io/posts/2017-09-16-docker_tips/","series":["工具"],"tags":["docker","tips"],"title":"docker tips"},{"categories":["技术"],"content":"环境:centos7,docker 1.12+，registry 2.\n一、准备工作: mkdir /data/docker-registry mkdir /data/docker-registry-auth 二、安全设置: 生成 http 密码文件\ndocker run --entrypoint htpasswd registry:2 -Bbn anycloud \u0026#39;123\u0026#39;\u0026gt; /data/docker-registry-auth/htpasswd 获取 SSL 证书 git clone https://github.com/letsencrypt/letsencrypt cd letsencrypt ./letsencrypt-auto --help ./letsencrypt-auto certonly --standalone -d \u0026lt;HOST\u0026gt; 三、启动: 新增systemd守护服务,内容如下\ncat /etc/systemd/system/multi-user.target.wants/docker-registry.service [Unit] Description=registry Requires=docker.service After=docker.target [Service] Restart=always RestartSec=20 TimeoutStartSec=5min ExecStartPre=-/usr/bin/docker kill registry ExecStart=/usr/bin/docker run -p 5000:5000 --name registry \\ -v /data/docker-registry-auth/:/certs \\ -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/fullchain.pem \\ -e REGISTRY_HTTP_TLS_KEY=/certs/privkey.pem \\ -e REGISTRY_STORAGE_DELETE_ENABLED=true \\ -v /data/docker-registry-auth/:/auth \\ -e \u0026#34;REGISTRY_AUTH=htpasswd\u0026#34; \\ -e \u0026#34;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm\u0026#34; \\ -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \\ -e REGISTRY_STORAGE_DELETE_ENABLED=true \\ -v /data/docker-registry/:/var/lib/registry \\ registry:2 ExecStartPost=-/usr/bin/docker rm registry ExecStop=/usr/bin/docker stop registry ExecStopPost=-/usr/bin/docker rm registry [Install] WantedBy=multi-user.target 启动registry\nsystemctl daemon-reload systemctl start docker-registry 四、检验: 浏览器 https://localhost:5000/v2/ 密码登入,假如 显示 {} 之类的json文本,则说明成功。\n","date":"2017-09-01","img":"","permalink":"https://fabletang.github.io/posts/2017-09-01-docker_registry/","series":["工具"],"tags":["docker"],"title":"docker私有仓库搭建"},{"categories":["技术"],"content":"Go的设计思想是代码至上，依赖于代码而不是象其它语言依赖于编译好的库。尽管go的版本号已经到1.8.1了,但是还没没有好的package版本管理策略。1.6推出的vender只是稍微缓解了困境,只有寄希望与将来的1.9版本了。Go的代码结构不同于其它语言的地方,以java为对照:\n代码文件位于src目录 假如GOPATH对应项目goprojectstruct,代码文件应该处于 goprojectstruct/src目录内.\nGo无class的概念 Go无对象编程的类class的概念。所以代码文件名称可以随意定义，但是一般位于package目录,一般与package同名，但是拆分成几个文件也是可以的。\n代码文件/package名为小写 Java文件名一般为大写。Go以简单为宗旨，显然小写字母要简单,也符合go的定义，小写代表私有private，大写代表公开public。\n单元测试文件 单元测试文件与被测试文件处于同一目录，文件名追加\u0026quot;_test\u0026quot;,比如 hello.go的测试文件为 hello_test.go.\n引用库位于vender 所有外来引入的package都应该处于vender目录下。.gitignore也应该忽略vender目录。以此保持代码结构的精简。\npackage版本管理 在go1.9之前，推荐采用glide来管理。\n","date":"2017-05-01","img":"","permalink":"https://fabletang.github.io/posts/2017-05-01-the_struct_of_go_project/","series":["编程"],"tags":["golang"],"title":"Golang代码结构"},{"categories":["技术"],"content":"得益于nginx等反向代理的流行以及metrics/endpoit规范的成熟。微服务的理念开始流行了。 但是微服务究竟要多\u0026quot;微\u0026quot;才合适？以下是我的个人实践。\n不能按接口分: 这样的粒度太细.比如新增订单/查询订单分为两个microservice,优点是可以根据各自的负载合理分配服务器 资源。缺点是microservice数量过多，这样拆分的话，至少存在几十个service，这样对service的依赖关系，监控 ／部署都增加很大的难度。\n不能按数据库表名(table)分: 这是个鲁莽的做法。很明显，数据库的的事务处理将极为棘手。\n不能按数据库名(db)分: 这样的粒度太粗.好处是本地数据库数据一致性问题很好解决。缺点是功能过于集中，不利于后期改进。\n建议按子业务分，同时考虑数据库表的关联: 比如按订单/用户管理这样的粒度分，数据库表相对独立。这样service的数量较为合适，语意上也容易理解。\n","date":"2017-04-01","img":"","permalink":"https://fabletang.github.io/posts/2017-04-01-granularity_of_microservice/","series":["概念"],"tags":["practice"],"title":"微服务的粒度"},{"categories":["技术"],"content":"stateless server 即无状态服务。相对与传统的http server存在session,无session的 http server称为stateless server，现在一般应用于restful service.\nWhy: session的概念存在这么多年，一定有其合理之处,为什么要抛弃它?\n  session的起源: session根源于http的cookie. http协议本身是无状态的协议，server是一问一答，答后不管。为了加入 状态，来辨识是否访问／是否登录的需要，加入了cookie。服务器的session就是对应浏览器端的cookie.\n  为什么抛弃session:\n  高并发的访问，session制约了server的水平扩展。在负载均衡的多个server群，虽然可以用高速缓存比 如redis来管理全局session.但是毕竟多存在了一个节点，削弱了系统稳定性。\n  session需要资源开销，在tomcat中，每个session至少耗费4k内存。\n  session存在安全缺陷，一般session会以明文形式写入cookie,cookie是保存在浏览器端的硬盘，由此引发 的安全问题可以写成一本书了。即使禁用cookie, session也容易被窃取，CSRF跨域攻击就是窃取session的 安全问题。\n  随着server的功能增多，有时候需要跨域访问的时候，session成为了障碍。比如网页需要访问两个服务器的 资源，而且都必须要要登录授权保持状态,这样需要两个sessionid,但是浏览器只支持单一session.\n  What: stateless server是否就是服务器不需要state状态？ 需要授权的资源如果不保存其状态，比如用户id／角色。每次访问都要重新提交验证信息。服务器可能要重复 验证／查询数据库,这样会带来额外的资源开销。 所以，stateless应该理解为服务器不保存状态。\nHow: server需要状态，但是不保存状态。怎么做？ 采用jwt,状态保存在客户端。jwt 即json web token. server 把状态放入jwt,加密，以字符串的方式发送给客户端。\n采用jwt的好处:\n 可以封装状态，以key／value字符的形式保存状态。 安全。jwt一般采用对称或者非对称加密。加密密钥存放在server.可以防止jwt被篡改。jwt同时有时效性，合适的有效期可以减少重放攻击的可能性。  ","date":"2017-01-01","img":"","permalink":"https://fabletang.github.io/posts/2017-01-01-stateless_server/","series":["概念"],"tags":["practice"],"title":"stateless server 最佳实践"},{"categories":["管理"],"content":"\u0026ldquo;凡事预则立 不预则废\u0026rdquo;,这是\u0026laquo;礼记\u0026raquo;中的名言,意思是任何事情不作计划就会失败。\n软件项目也一样必须作计划。但是实际情况是，软件项目很难预估资源和时间。软件开发中\n有个“公理”：20%的工作要花费80%的时间。二八原理。还有一个\u0026quot;20%的项目是成功，80%\u0026quot;\n将失败\u0026quot;。说明软件项目很难作出贴近实际的计划(schedule)。Why?\n特性: 软件项目大多是创造性，难度大，复杂程度高。就单单编程语言来说，在电脑领域已发 明了上千不同的编程语言，而且每年仍有新的编程语言诞生。\n资源: 软件项目的主要资源:人,是稀缺的。需要较高技能要求。\n","date":"2015-10-06","img":"","permalink":"https://fabletang.github.io/posts/2015-10-06-project-schedule/","series":["心得"],"tags":["project"],"title":"关于软件项目计划的看法"},{"categories":["技术"],"content":"Grails是一套用于快速Web应用开发的开源框架，它基于Groovy编程语言，并构建于Spring、Hibernate等开源框架之上，是一个高生产力一站式框架。其官方网站上的煽情介绍为：The search is over!, 即为不要再苦苦寻找web开发框架了，Grails是终结者。\n如果web项目组大部分懂java，又没有旧的web项目负担。Grails是明智的选择。 缺点: groovy是类java的脚本解释动态语言，尽管其兼容java所有语法，最终也运行于JVM,但是速度有所影响.总体grails 比rails快，慢于传统ssh(struts/spring/hiberate)框架. 除了稍慢的运行速度，grails相对SSH全面胜出，以下是论点:\n一、学习成本低:  groovy语法不用学习，如果懂得java,groovy就是秒懂，实在不行，完全用java的语法也没有任何问题。其实注重运行速度的功能，比如加密解密，数据排序等算法推荐用java编写，groovy可以无缝引用。 grails的springframework\\hibernat极易使用，基本不用学习，完全不用理会那些迷宫式xml配置。grails会自动帮你处理好。  二、开发速度快:  grails 不是粗糙的ssh,它甚至有命令控制台，比如 grails create-control abc.login,就自动创建好了control及相关的测试文件。不用手动建立目录，建立文件。 调试便捷，run-app命令就可以运行一个web服务器，不需要启动额外的tomcat或者其他web容器, 同时它还是热编译的，也就是说，运行期间，你改动代码，grail自动就编译好了，不需要重新启动，哪怕你改动control都可以。 3.groovy语言大大减少了java的繁杂，同时集成很多通用库，可以大大减少代码.  三、功能完善: ssh是个粗糙的框架，不怀疑可以很快写出一个CURD的功能块。但是这远远不能应付实际项目需求，还得做大量的工作。\n  view层： grails 集成了sitmesh模版，而且自动加载缓存，模块化view。GSP相对structs的标签更好用。\n  control层: view数据绑定支持list,可以实现多维数据结构。spring mvc只支持map/bean 键值绑定方式。数据渲染很容易实现json/xml输出。比如 render xxxxbean as JSON\n  model层: 易于处理多对多，一对多，级联删除，完全不用去配置hibernat XML. 脏数据处理，数据缓存默认集成。\n  测试功能完备，易于使用，m/v/c各层都容易实现测试.\n  其他小功能完备，比如内置一个内存数据库，项目发布时候无缝切换实际数据库。\n  四、项目易于管理:  Grails 的原则是约定大于配置，也就是说配置文件，文件目录，命名方式都是约定好的。开放人员就是做填空题。项目自然就规范了。 Grails大大减少了配置文件，groovy语法大大缩减了代码量，越少的编码意味更好维护。 Grails开发模式下的热部署功能给前端开发提供很大便利，可以不重启web容器就可以即使得到改动的效果。这样利于前端后端开发分工。  ","date":"2014-12-25","img":"","permalink":"https://fabletang.github.io/posts/2014-12-25-grails_intro/","series":["框架"],"tags":["java"],"title":"Grails框架介绍"},{"categories":null,"content":"鄙人喜欢狗，对养鱼这种雅趣向来不屑一顾。几个月前儿子笑盈盈地提着一个透明小水盒，\n得意的炫耀他钓的金鱼。原来是公园的付费小娱乐，每次十元，规定时间内钓的金鱼就可以\n带回。我瞅了瞅，6条小金鱼，不是锦鲤，也不是那种鱼鳍眼睛特别大的金鱼，就是鱼鳍比一般\n鲤鱼大一点，颜色更鲜艳的金色小鲤鱼, 不是什么名贵品种。似乎刚被勾上来，神情恹恹，浮在\n透明塑料小盒子里。看来没几天好活，不忍心打击儿子的童心，便答应养着。\n一个星期后，死了一条，剩下5条居然活了下来，使劲游水，已经适应了环境。就多留意了一些，\n晚上睡觉的时候，也偶尔听到小鱼吧嗒水泡的声音，似乎是小水盒太挤，氧气不足,所以游在水面\n上吐泡泡。\n又过了大半个月，5条金鱼没减员，而且更见活泼。每次投食都聚集过来吐泡泡，拼命摆动尾巴。\n好吧，毕竟是5条生命，既然安了家，就一起生活吧。催着家人去菜市场买个大点的鱼缸。\n几天后，金鱼就快活的游在一个椭圆形的玻璃缸里，后来听人说水草能改水质, 就买了几根鞭子\n一样的水草，但是没多久叶子就被啃光了。 每天早晚两次投食，应该没这么饿吧。跟人交流，对方\n也是惊诧, 我嘴里说着这鱼是个吃货，心里居然有小小的得意。\n后来那个小的椭圆形玻璃缸，因为每3天要换水，不小心磕坏了。\n现在是一个20cm20cm20cm的小鱼缸(家里太小),安装了一个2w的过滤器，水流冲下来带来小气泡，\n兼任加氧的功能。不打算用那种自动偷食，光照，加氧，调温，过滤的专业鱼箱。又讨来几个石螺，\n帮忙清理排泄物。这样就不用3天整个换水了，一周换几杯水就够了。\n每次靠近鱼箱，小家伙们就凑过来，拼命吐泡泡，摇尾巴。看来以后要一起生活了。 ^_^\n","date":"2014-10-19","img":"","permalink":"https://fabletang.github.io/posts/2014-10-19-goldfish/","series":null,"tags":["others"],"title":"养金鱼"},{"categories":["技术"],"content":"gradle 现在已经2.1版本了。从1.0版本就一直关注这个groovy项目，但是没有应用到\n公司项目的打算，但是现在时机到了。gradle已经是最好的java自动构建工具，没有之一。\n一、gradle基于动态语言groovy groovy是java的动态版，闭包的特性让其编译脚本更加自由。\n比如你可以指定项目的某个目录用特定jdk版本编译。\n二、gradle 可以完全利用已有的maven库资源 maven库资源已经发展非常成熟，几乎没有找不到的开源库。\n三、gradle插件非常丰富，已经支持android项目构建。 没错，你现在可以用gradle一个命令实现android项目的编译，打包，上传，运行。\n插件: com.android.tools.build:gradle:0.13,已经可以胜任任何android项目构建，包括NDK.\nAndroid Studio 0.8.12 已经非常成熟，可以自动生成gradle.build配置文件。\n至于普通的java构建，就没有gradle不能做的。\n四、gradle学习成本低 gradle学习成本很低，比ant低，比maven低。但是更加强大。\n","date":"2014-10-13","img":"","permalink":"https://fabletang.github.io/posts/2014-10-13-introduce-gradle/","series":["工具"],"tags":["toolbox"],"title":"Gradle 介绍"},{"categories":["技术"],"content":"由于长期在linux下做开发，严重依赖linux的各种小方便，然而需要参与一个Android项目。 项目里有公司开发的.so，涉及了JNI。开始我使用的是eclipse ADT, linux 的usb联机调试也 搞定了，一切似乎都很顺利，usb联机上传也成功了，app出来了，点击，然后就崩溃了，logcat 提示找不到 XXX.so。本来就对eclipse这个老破车有成见，利用这个借口，开始用android studio\n环境说明:\nUbuntu /Windows, android studio 0.8.6+\n以下是要点：\n一、studio 可以直接从eclipse导入,gradle build成功，但是出现编码错误（\\78XXX) 这个是编码错误，用笨办法，右键出错文件，enconding GBK, 然后再 UTF-8.\n二、编译通过，但是联机调试出现上传错误，提示XX.jar重复copy. 这个是studio本身bug, 在 app下的build.gradle 的 android {\u0026hellip;}内加入\npackagingOptions { exclude \u0026#39;META-INF/DEPENDENCIES.txt\u0026#39; exclude \u0026#39;META-INF/LICENSE.txt\u0026#39; exclude \u0026#39;META-INF/NOTICE.txt\u0026#39; exclude \u0026#39;META-INF/NOTICE\u0026#39; exclude \u0026#39;META-INF/LICENSE\u0026#39; exclude \u0026#39;META-INF/DEPENDENCIES\u0026#39; exclude \u0026#39;META-INF/notice.txt\u0026#39; exclude \u0026#39;META-INF/license.txt\u0026#39; exclude \u0026#39;META-INF/dependencies.txt\u0026#39; exclude \u0026#39;META-INF/LGPL2.1\u0026#39; } 三、local.properties 是定义 sdk.dir 和 ndk.dir.需要根据本机andoird jdk情况调整。 四、JNI 相关的问题:   android studio 的ndk 不完善，没有eclipse支持那么好。但是也是可以用的，需要在build.gradle\n里配置，具体请参看gradle官方文档.\n  JNI生成的.so打包apk。.so位于 libs/armeabi 目录,在 app下的build.gradle 的 android {\u0026hellip;}内加入\n  sourceSets { main { jniLibs.srcDirs = [\u0026#39;libs\u0026#39;] } } ","date":"2014-09-30","img":"","permalink":"https://fabletang.github.io/posts/2014-09-30-android-studio-conf/","series":["工具"],"tags":["android","tips"],"title":"Android Studio 配置"},{"categories":["技术"],"content":"环境说明: Ubuntu 14.04, android ADT 4.2.2\nLinux 下 ADT usb联机调试出现 device unknown 的解决办法:\n一、使用lsusb命令查看设备的vendorId和productId。 插入usb线前后用lsusb查看，找出多出的信息。\n$ lsusb Bus 003 Device 005: ID 0bb4:0c03 HTC (High Tech Computer Corp.) 二、在/etc/udev/rules.d/目录下面新建一个规则文件 51-android.rules 添加一行 SUBSYSTEM==\u0026#34;usb\u0026#34;,ATTRS {idVendor}==\u0026#34;0bb4\u0026#34;,ATTRS {idProduct}==\u0026#34;0c03\u0026#34;,MODE=\u0026#34;0666\u0026#34; 0666 表示对所有用户，开放adb所有权限\n三、 重启usb服务，命令如下： sudo service udev restart 四、 重置ADB  拔下USB与PC连接线，然后再次插上，进入Android-SDK根目录Platform-tools，运行命令:\n$which adb $sudo ./adb kill-server $sudo ./adb devices 五、 把adb命令加入环境变量 查找adb所在路径\n$which adb 编辑~/.bashrc文件,增加\nexport PATH=.:$PATH:adb路径 这样就不用每次进入adb目录了。\n","date":"2014-09-29","img":"","permalink":"https://fabletang.github.io/posts/2014-09-29-android-usb-ubunit/","series":["工具"],"tags":["android","tips"],"title":"Ubuntu下Android USB联机调试"}]
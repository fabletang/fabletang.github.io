<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>practice on 知行合一</title>
    <link>https://fabletang.github.io/tags/practice/</link>
    <description>Recent content in practice on 知行合一</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 01 Apr 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://fabletang.github.io/tags/practice/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>微服务的粒度</title>
      <link>https://fabletang.github.io/2017/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%B2%92%E5%BA%A6/</link>
      <pubDate>Sat, 01 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/2017/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%B2%92%E5%BA%A6/</guid>
      <description>得益于nginx等反向代理的流行以及metrics/endpoit规范的成熟。微服务的理念开始流行了。 但是微服务究竟要多&amp;quot;微&amp;quot;才合适？以下是我的个人实践。
不能按接口分: 这样的粒度太细.比如新增订单/查询订单分为两个microservice,优点是可以根据各自的负载合理分配服务器 资源。缺点是microservice数量过多，这样拆分的话，至少存在几十个service，这样对service的依赖关系，监控 ／部署都增加很大的难度。
不能按数据库表名(table)分: 这是个鲁莽的做法。很明显，数据库的的事务处理将极为棘手。
不能按数据库名(db)分: 这样的粒度太粗.好处是本地数据库数据一致性问题很好解决。缺点是功能过于集中，不利于后期改进。
建议按子业务分，同时考虑数据库表的关联: 比如按订单/用户管理这样的粒度分，数据库表相对独立。这样service的数量较为合适，语意上也容易理解。</description>
    </item>
    
    <item>
      <title>stateless server 最佳实践</title>
      <link>https://fabletang.github.io/2017/01/stateless-server-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Sun, 01 Jan 2017 00:00:00 +0000</pubDate>
      
      <guid>https://fabletang.github.io/2017/01/stateless-server-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
      <description>stateless server 即无状态服务。相对与传统的http server存在session,无session的 http server称为stateless server，现在一般应用于restful service.
Why: session的概念存在这么多年，一定有其合理之处,为什么要抛弃它?
  session的起源: session根源于http的cookie. http协议本身是无状态的协议，server是一问一答，答后不管。为了加入 状态，来辨识是否访问／是否登录的需要，加入了cookie。服务器的session就是对应浏览器端的cookie.
  为什么抛弃session:
  高并发的访问，session制约了server的水平扩展。在负载均衡的多个server群，虽然可以用高速缓存比 如redis来管理全局session.但是毕竟多存在了一个节点，削弱了系统稳定性。
  session需要资源开销，在tomcat中，每个session至少耗费4k内存。
  session存在安全缺陷，一般session会以明文形式写入cookie,cookie是保存在浏览器端的硬盘，由此引发 的安全问题可以写成一本书了。即使禁用cookie, session也容易被窃取，CSRF跨域攻击就是窃取session的 安全问题。
  随着server的功能增多，有时候需要跨域访问的时候，session成为了障碍。比如网页需要访问两个服务器的 资源，而且都必须要要登录授权保持状态,这样需要两个sessionid,但是浏览器只支持单一session.
  What: stateless server是否就是服务器不需要state状态？ 需要授权的资源如果不保存其状态，比如用户id／角色。每次访问都要重新提交验证信息。服务器可能要重复 验证／查询数据库,这样会带来额外的资源开销。 所以，stateless应该理解为服务器不保存状态。
How: server需要状态，但是不保存状态。怎么做？ 采用jwt,状态保存在客户端。jwt 即json web token. server 把状态放入jwt,加密，以字符串的方式发送给客户端。
采用jwt的好处:
 可以封装状态，以key／value字符的形式保存状态。 安全。jwt一般采用对称或者非对称加密。加密密钥存放在server.可以防止jwt被篡改。jwt同时有时效性，合适的有效期可以减少重放攻击的可能性。  </description>
    </item>
    
  </channel>
</rss>
